import{_ as n,W as a,X as s,$ as e,Z as p}from"./framework-9e67db09.js";const c={},t=p(`<p>上篇文章中我们分析完了Spring中Bean的实例化过程，但是没有对循环依赖的问题进行分析，这篇文章中我们来看一下spring是如何解决循环依赖的实现。</p><p>之前在讲spring的过程中，我们提到了一个spring的单例池<code>singletonObjects</code>，用于存放创建好的bean，也提到过这个Map也可以说是狭义上的spring容器。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> singletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其实spring在缓存bean的过程中并不是只有这一个Map，我们看一下<code>DefaultSingletonBeanRegistry</code>这个类，在其中其实存在3个Map，这也就是经常提到的spring三级缓存。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> singletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token doc-comment comment">/** Cache of early singleton objects: bean name --&gt; bean instance */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> earlySingletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token doc-comment comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">ObjectFactory</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> singletonFactories <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">ObjectFactory</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上到下分别为一到三级缓存，这里先对三级缓存有一个初步的认识，后面使用到的时候我们再详细分析。</p><h2 id="循环依赖实现流程" tabindex="-1"><a class="header-anchor" href="#循环依赖实现流程" aria-hidden="true">#</a> 循环依赖实现流程</h2><p>下面开始分析spring循环依赖的注入实现过程。先写两个bean，在它们中分别注入了对方：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceA</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Autowired</span>
  <span class="token class-name">ServiceB</span> serviceB<span class="token punctuation">;</span>  
  
  <span class="token keyword">public</span> <span class="token class-name">ServiceB</span> <span class="token function">getServiceB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;get ServiceB&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> serviceB<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceB</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Autowired</span>
  <span class="token class-name">ServiceA</span> serviceA<span class="token punctuation">;</span>  
  
  <span class="token keyword">public</span> <span class="token class-name">ServiceA</span> <span class="token function">getServiceA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> serviceA<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>进行测试，分别调用它们的get方法，能够正常获得bean，说明循环依赖是可以实现的：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code>com.hydra.service.ServiceB@58fdd99
com.hydra.service.ServiceA@6b1274d2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>首先，回顾一下上篇文章中讲过的bean实例化的流程。下面的内容较多依赖于spring的bean实例化源码，如果不熟悉建议花点时间阅读一下上篇文章。</p><p>在<code>AbstractAutowireCapableBeanFactory</code>的<code>doCreateBean</code>方法中，调用<code>createBeanInstance</code>方法创建一个原生对象，之后调用<code>populateBean</code>方法执行属性的填充，最后调用各种回调方法和后置处理器。</p><p>但是在执行<code>populateBean</code>方法前，上篇文章中省略了一些涉及到循环依赖的内容，看一下下面这段代码：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d19b12ba0d514dcc871f90d8889dc450~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>上面的代码先进行判断：如果当前创建的是单例bean，并且允许循环依赖，并且处于创建过程中，那么执行下面的<code>addSingletonFactory</code>方法。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bce1a1ac65ee4210a25d8ec98a7b46c2~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>主要工作为将lambda表达式代表的<code>ObjectFactory</code>，放入三级缓存的Map中。注意这里只是一个存放的操作，并没有实际执行lambda表达式中的内容，具体调用过程是在后面调用ObjectFactory的getObject方法时调用。这个方法执行完成后，三级缓存中存放了一条<code>serviceA</code>的数据，二级缓存仍然为空。</p><p>回到正常调用流程，生成原生对象后，调用<code>populateBean</code>方法进行属性的赋值也就是依赖注入，具体是通过执行<code>AutowiredAnnotationBeanPostProcessor</code>这一后置处理器的<code>postProcessPropertyValues</code>方法。</p><p>在这一过程中，<code>serviceA</code>会找到它依赖的<code>serviceB</code>这一属性，当发现依赖后，会调用<code>DefaultListableBeanFactory</code>的<code>doResolveDependency</code>方法，之后执行<code>resolveCandidate</code>方法，在该方法中，尝试使用<code>beanFactory</code>获取到<code>serviceB</code>的bean实例。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">resolveCandidate</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> requiredType<span class="token punctuation">,</span> <span class="token class-name">BeanFactory</span> beanFactory<span class="token punctuation">)</span>
      <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这时和之前没有循环依赖时的情况就会有些不一样了，因为现在<code>serviceB</code>还没有被创建出来，所以通过<code>beanFactory</code>是无法直接获取的。因此当在<code>doGetBean</code>方法中调用<code>getSingleton</code>方法会返回一个null值：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cecf7e61f5e451493bc095e7f2d2206~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>因此，继续使用与之前相同的创建bean的流程，实例化<code>serviceB</code>的bean对象。当<code>serviceB</code>的原生对象被实例化完成后，同样可以看到它依赖的<code>serviceA</code>还没有被赋值：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c165b8642b5f4e2597dc8f37e43a464e~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>创建完<code>serviceB</code>的原生对象后，同样执行<code>addSingletonFactory</code>方法，将<code>serviceB</code>放入三级缓存中，执行完成后，三级缓存中就已经存在了两个bean的缓存：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65003f1fc9ee46bab0a295ccb570121d~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>向下执行，<code>serviceB</code>会调用<code>populateBean</code>方法进行属性填充。和之前<code>serviceA</code>依赖<code>serviceB</code>相同的调用链，执行到<code>resolveCandidate</code>方法，尝试使用<code>beanFactory</code>的<code>getBean</code>去获取<code>serviceA</code>。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b350ebb21fc471b8777106c26424d6c~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>向下执行，调用<code>getSingleton</code>方法尝试直接获取<code>serviceA</code>，此时三级缓存<code>singletonFactories</code>中我们之前已经存进去了一个key为<code>serviceA</code>的<code>beanName</code>，value为lambda表达式，这时可以直接获取到。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db09067428544e54b3f08dfccba40def~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>在执行<code>singletonFactory</code>的<code>getObject</code>方法时才去真正执行lambda表达式中的方法，实际执行的是<code>getEarlyBeanReference</code>方法：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3921a6b9be504f3a9aacf0e4a8dc7f78~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>在遍历后置处理器后，获取到<code>serviceA</code>的执行过后置处理器后的对象，执行：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里将<code>serviceA</code>放入二级缓存<code>earlySingletonObjects</code>，并从三级缓存<code>singletonFactories</code>中移除。在这一步执行完后，三级缓存中的<code>serviceA</code>就没有了。</p><p>当我们从缓存中获取了<code>serviceA</code>的bean后，就不会再调用<code>createBean</code>去重复创建新的bean了。之后，顺调用链返回<code>serviceB</code>调用的<code>doResolveDependency</code>方法：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9abbe1bfb8a2437a8d49c68759aaa899~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p><code>serviceB</code>就成功获取到了它的依赖的<code>serviceA</code>属性的bean对象，回到<code>inject</code>方法，使用反射给<code>serviceA</code>赋值成功。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62acc55e58704432803c760d849eee18~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>回到<code>doCreateBean</code>的方法，可以看到<code>serviceB</code>的<code>serviceA</code>属性已经被注入了，但是<code>serviceA</code>中的<code>serviceB</code>属性还是<code>null</code>。说明<code>serviceB</code>的依赖注入已经完成，而<code>serviceA</code>的依赖注入还没做完。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89fe9597a8864e649b50edda6f9da15a~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>现在我们梳理一下运行到这里的流程：</p><p>1、在<code>serviceA</code>填充属性过程中发现依赖了<code>serviceB</code>，通过<code>beanFactory</code>的<code>getBean</code>方法，尝试获取<code>serviceB</code></p><p>2、<code>serviceB</code>不存在，执行了一遍<code>serviceB</code>的创建流程，填充属性时发现<code>serviceA</code>已经存在于三级缓存，直接注入给<code>serviceB</code></p><p>可以看到，在创建<code>serviceA</code>的过程中发现依赖的<code>serviceB</code>不存在，转而去创建了<code>serviceB</code>，而创建<code>serviceA</code>的流程并没有执行完，因此在创建完<code>serviceB</code>后再顺调用链返回，直到<code>doResolveDependency</code>方法：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecefe77ebe114e71948a9db531cc1c9d~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>可以看到，需要依赖的<code>serviceB</code>已经被创建并返回成功，返回到<code>inject</code>方法，同样通过反射给<code>serviceB</code>赋值：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/197c39314ade4da9858b4f5f8fc60bad~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>返回<code>doCreateBean</code>方法，可以看到<code>serviceA</code>和<code>serviceB</code>之间的循环依赖已经完成了：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55f790a26f7c4b3abba86403e80fed7a~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>这样，一个最简单的循环依赖流程就结束了。有的小伙伴可能会提出疑问，这样的话，我只需要添加一个缓存存放原生对象就够了啊，为什么还需要二级缓存和三级缓存两层结构呢？</p><h2 id="aop下循环依赖具体实现" tabindex="-1"><a class="header-anchor" href="#aop下循环依赖具体实现" aria-hidden="true">#</a> AOP下循环依赖具体实现</h2><p>我们看看下面的例子，前面的两个serviceA和serviceB不变，我们添加一个<code>BeanPostProcessor</code>：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyPostProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">BeanPostProcessor</span> <span class="token punctuation">{</span>
   <span class="token annotation punctuation">@Override</span>
   <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>beanName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;serviceA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
           <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;create new ServiceA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ServiceA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">return</span> bean<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行一下，结果报错了：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Exception</span> in thread <span class="token string">&quot;main&quot;</span> <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span></span>BeanCurrentlyInCreationException</span><span class="token operator">:</span> 
<span class="token class-name">Error</span> creating bean <span class="token keyword">with</span> <span class="token namespace">name</span> &#39;serviceA&#39;<span class="token operator">:</span> <span class="token class-name">Bean</span> <span class="token keyword">with</span> <span class="token namespace">name</span> &#39;serviceA&#39; 
has been injected into other beans <span class="token punctuation">[</span>serviceB<span class="token punctuation">]</span> in its raw version as 
part of a circular reference<span class="token punctuation">,</span> but has eventually been <span class="token class-name"><span class="token namespace">wrapped<span class="token punctuation">.</span></span> This</span> 
means that said other beans <span class="token keyword">do</span> not use the <span class="token keyword">final</span> version of the <span class="token class-name"><span class="token namespace">bean<span class="token punctuation">.</span></span>
This</span> is often the result of over<span class="token operator">-</span>eager type matching <span class="token operator">-</span> consider 
using &#39;getBeanNamesOfType&#39; <span class="token keyword">with</span> <span class="token namespace">the</span> &#39;allowEagerInit&#39; flag turned 
off<span class="token punctuation">,</span> <span class="token keyword">for</span> example<span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在分析错误之前，我们再梳理一下正常循环依赖的过程：</p><p>1、初始化原生对象serviceA，放入三级缓存</p><p>2、serviceA填充属性，发现依赖serviceB，创建依赖对象</p><p>3、创建serviceB，填充属性发现依赖serviceA，从三级缓存中找到填充</p><p>4、执行serviceB的后置处理器和回调方法，放入单例池</p><p>5、执行serviceA的后置处理器和回调方法，放入单例池</p><p>再回头看上面的错误，大意为在循环依赖中我们给serviceB注入了serviceA，但是注入之后我们又在后置处理器中对serviceA进行了包装，因此导致了serviceB中注入的和最后生成的serviceA不一致。</p><p>但是熟悉aop的同学应该知道，aop的底层也是利用后置处理器实现的啊，那么为什么aop就可以正常执行呢？我们添加一个切面横切serviceA的<code>getServiceB</code>方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@Aspect</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAspect</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">&quot;execution(* com.hydra.service.ServiceA.getServiceB())&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> pjp<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">try</span><span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;execute aop around method&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            pjp<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>先不看运行结果，代码可以正常执行不出现异常，那么aop是怎么实现的呢？</p><p>前面的流程和不使用aop相同，我们运行到serviceB需要注入serviceA的地方，调用<code>getSingleton</code>方法从三级缓存中获取serviceA存储的<code>singletonFactory</code>，调用<code>getEarlyBeanReference</code>方法。在该方法中遍历执行<code>SmartInstantiationAwareBeanPostProcessor</code>后置处理器的<code>getEarlyBeanReference</code>方法：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9693e989be004180a9230cadfff63fe2~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>看一下都有哪些类实现了这个方法：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8388998fc9e9493ebed512f6a4f590e8~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>在spring中，就是这个<code>AbstractAutoProxyCreator</code>负责实现了aop，进入<code>getEarlyBeanReference</code>方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getEarlyBeanReference</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
    <span class="token comment">//beanName</span>
    <span class="token class-name">Object</span> cacheKey <span class="token operator">=</span> <span class="token function">getCacheKey</span><span class="token punctuation">(</span>bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>earlyProxyReferences<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token comment">//产生代理对象</span>
    <span class="token keyword">return</span> <span class="token function">wrapIfNecessary</span><span class="token punctuation">(</span>bean<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> cacheKey<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>earlyProxyReferences</code> 是一个Map，用于缓存bean的原始对象，也就是执行aop之前的bean，非常重要，在后面还会用到这个Map：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> earlyProxyReferences <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>记住下面这个<code>wrapIfNecessary</code>方法，它才是真正负责生成代理对象的方法：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5655636517049529d50124e0ad33f64~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>上面首先解析并拿到所有的切面，调用<code>createProxy</code>方法创建代理对象并返回。然后回到<code>getSingleton</code>方法中，将serviceA加入二级缓存，并从三级缓存中移除掉。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc1248918d6343fe8630f7d0c8d3e864~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>可以看到，二级缓存中的serviceA已经是被cglib代理过的代理对象了，当然这时的serviceA还是没有属性值填充的。</p><p>那么这里又会有一个问题，我们之前讲过，在填充完属性后，会调用后置处理器中的方法，而这些方法都是基于原始对象的，而不是代理对象。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f94d256d5b094a91adb1005c24571f94~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>在前一篇文章中我们也讲过，在<code>initializeBean</code>方法中会执行后置处理器，并且正常情况下aop也是在这里完成的。那么我们就要面临一个问题，如果避免重复执行aop的过程。在<code>initializeBean</code>方法中：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>mbd <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>mbd<span class="token punctuation">.</span><span class="token function">isSynthetic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  wrappedBean <span class="token operator">=</span> <span class="token function">applyBeanPostProcessorsAfterInitialization</span><span class="token punctuation">(</span>wrappedBean<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调用<code>applyBeanPostProcessorsAfterInitialization</code>，执行所有后置处理器的<code>after</code>方法：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cd513ce0c88496fb1136d6e549d1ff8~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>执行<code>AbstractAutoProxyCreator</code>的<code>postProcessAfterInitialization</code>方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Object</span> cacheKey <span class="token operator">=</span> <span class="token function">getCacheKey</span><span class="token punctuation">(</span>bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>earlyProxyReferences<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">)</span> <span class="token operator">!=</span> bean<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">wrapIfNecessary</span><span class="token punctuation">(</span>bean<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> cacheKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> bean<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>earlyProxyReferences</code> 我们之前说过非常重要，它缓存了进行aop之前的原始对象，并且这里参数传入的Object也是原始对象。因此在这里执行<code>remove</code>操作的判断语句返回<code>false</code>，不会执行if中的语句，不会再执行一遍aop的过程。</p><p>回过头来再梳理一下，因为之前进行过循环依赖，所以提前执行了<code>AbstractAutoProxyCreator</code>的<code>getEarlyBeanReference</code>方法，执行了aop的过程，在<code>earlyProxyReferences</code>中缓存了原生对象。因此在循环依赖的情况下，等式成立，直接返回。而在没有循环依赖的普通情况下，<code>earlyProxyReferences</code>执行<code>remove</code>返回为<code>null</code>，等式不成立，正常执行aop流程。</p><p>需要注意的是，这个方法中最终返回的还是原始对象，而不是aop后的代理对象。执行到这一步，我们先看一下嵌套的状态：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f52f549a6ec4841b303194c0df92844~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>对外暴露的serviceA是原始对象，依赖的serviceB已经被注入了。而serviceB中依赖的serviceA是代理对象，并且这个代理对象依赖的serviceB还没有被注入。</p><p>向下执行：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a875d7de1664848850eb17a1f419edc~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>再次通过<code>getSingleton</code>获取serviceA：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25fe47873b5b4b73802a3654867f6a35~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>这次我们通过二级缓存就可以拿到之前经过aop的代理对象，因此不用找三级缓存直接返回这个代理对象，并最终把这个代理对象添加到一级缓存单例池中。</p><p>到这，我们对三级缓存的作用做一个总结：</p><p>1、<code>singletonObjects</code>：单例池，缓存了经过完整生命周期的bean</p><p>2、<code>earlySingletonObjects</code>：缓存了提前曝光的原始对象，注意这里存的还不是bean，这里存的对象经过了aop的代理，但是没有执行属性的填充以及后置处理器方法的执行</p><p>3、<code>singletonFactories</code>：缓存的是<code>ObjectFactory</code>，主要用来去生成原始对象进行了aop之后得到的代理对象。在每个bean的生成过程中，都会提前在这里缓存一个工厂。如果没有出现循环依赖依赖这个bean，那么这个工厂不会起到作用，按照正常生命周期执行，执行完后直接把本bean放入一级缓存中。如果出现了循环依赖依赖了这个bean，没有aop的情况下直接返回原始对象，有aop的情况下返回代理对象。</p><p>全部创建流程结束，看一下结果：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6254e95574d14bb5995ede3ef49d53aa~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>我们发现，在生成的serviceA的<code>cglib</code>代理对象中，serviceB属性值并没有被填充，只有serviceB中serviceA的属性填充成功了。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d3870a2e2fa4367a4c1bf830d87034c~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>可以看到如果使用cglib，在代理对象的<code>target</code>中会包裹一个原始对象，而原始对象的属性是被填充过的。</p><p>那么，如果不使用cglib代理，而使用jdk动态代理呢？我们对之前的代码进行一下改造，添加两个接口：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IServiceA</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">IServiceB</span> <span class="token function">getServiceB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IServiceB</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">IServiceA</span> <span class="token function">getServiceA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>改造两个Service类：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceA</span> <span class="token keyword">implements</span> <span class="token class-name">IServiceA</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">IServiceB</span> serviceB<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">IServiceB</span> <span class="token function">getServiceB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;get ServiceB&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>serviceB<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceB</span> <span class="token keyword">implements</span> <span class="token class-name">IServiceB</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">IServiceA</span> serviceA<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">IServiceA</span> <span class="token function">getServiceA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;get ServiceA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> serviceA<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行结果：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c007a9bbdad143d793bec388fe5578a9~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>看一下serviceA的详细信息：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdf3cd2e172644a2bfc401a2ac3a3fe2~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>同样也是在<code>target</code>中包裹了原生对象，并在原生对象中注入了serviceB的实例。</p><p>综上两种方法，可以看出在我们执行serviceA的getServiceB方法时，都无法正常获取到其bean对象，都会返回一个<code>null</code>值。那么如果非要直接获得这个serviceB应该怎么办呢？</p><p>我们可以通过反射的方式，先看cglib代理情况下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ServiceA</span> serviceA<span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ServiceA</span><span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">&quot;serviceA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Field</span> h <span class="token operator">=</span> serviceA<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;CGLIB$CALLBACK_0&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
h<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Object</span> dynamicAdvisedInterceptor <span class="token operator">=</span> h<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>serviceA<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Field</span> advised <span class="token operator">=</span> dynamicAdvisedInterceptor<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;advised&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
advised<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Object</span> target <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">AdvisedSupport</span><span class="token punctuation">)</span>advised<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>dynamicAdvisedInterceptor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTargetSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ServiceA</span> serviceA1<span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ServiceA</span><span class="token punctuation">)</span> target<span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>serviceA1<span class="token punctuation">.</span><span class="token function">getServiceB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再看看jdk动态代理情况下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">IServiceA</span> serviceA <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">IServiceA</span><span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">&quot;serviceA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Field</span> h<span class="token operator">=</span>serviceA<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSuperclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;h&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
h<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">AopProxy</span> aopProxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">AopProxy</span><span class="token punctuation">)</span> h<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>serviceA<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Field</span> advised <span class="token operator">=</span> aopProxy<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;advised&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
advised<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Object</span> target <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">AdvisedSupport</span><span class="token punctuation">)</span>advised<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>aopProxy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTargetSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ServiceA</span> serviceA1<span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ServiceA</span><span class="token punctuation">)</span> target<span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>serviceA1<span class="token punctuation">.</span><span class="token function">getServiceB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行结果都能获取到serviceB的实例：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdc4accf670440aea20aa07378da1f1d~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>对aop情况下的循环依赖进行一下总结：spring专门为了处理aop情况下的循环依赖提供了特殊的解决方案，但是不论是使用jdk动态代理还是cglib代理，都在代理对象的内部包裹了原始对象，在原始对象中才有依赖的属性。此外，如果我们使用了后置处理器对bean进行包装，循环依赖的问题还是不能解决的。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>最后对本文的重点进行一下总结：</p><p>1、spring通过借助三级缓存完成了循环依赖的实现，这个过程中要清楚三级缓存分别在什么场景下发挥了什么具体作用</p><p>2、产生aop情况下，调用后置处理器并将生成的代理对象提前曝光，并通过额外的一个缓存避免重复执行aop</p><p>3、二级缓存和三级缓存只有在产生循环依赖的情况下，才会真正起到作用</p><p>4、此外，除去本文中提到的通过属性的方式注入依赖的情况外，大家可能会好奇如果使用构造函数能否实现循环依赖，结果是不可以的。具体的调用过程这里不再多说，有兴趣的同学可以自己再对照源码进行一下梳理。</p>`,131);function o(i,l){return a(),s("div",null,[e(" more "),t])}const d=n(c,[["render",o],["__file","circleDependency.html.vue"]]);export{d as default};
