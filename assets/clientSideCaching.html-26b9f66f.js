import{_ as n,W as o,X as s,$ as t,Y as e,a0 as i,a1 as c,Z as d,C as p}from"./framework-9e67db09.js";const r={},l=d('<p>在前面介绍两级缓存的文章中，我们总共给出了4种实现方案，在项目中整合了本地缓存<code>Caffeine</code>和远程缓存<code>Redis</code>，将应用的性能从仅适用单独远程缓存的基础上，再次提高了一个层次。</p><p>而今天Hydra要和大家分享的技术，在思想上和上面两级缓存有些类似，不过不需要借助其他本地缓存中间件，只使用<code>Redis</code>自身服务端和客户端就可以实现。这就是<code>Redis6</code>中的客户端缓存<code>Client-side caching</code>这一项新特性，它允许将数据缓存在<strong>应用服务端</strong>以及<strong>远程缓存</strong>两个位置。</p><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h2><p>客户端缓存是Redis6众多新特性中比较实用的一项新功能，我们看看官方文档，了解一下它的作用：</p><blockquote><p>客户端缓存是一种用于创建高性能服务的技术，它可以利用<strong>应用服务器</strong>上的可用内存（这些服务器通常是一些不同于数据库服务器的节点），在这些应用服务端来直接存储数据库中的一些信息。</p><p>与访问数据库等网络服务相比，访问本地内存所需要的时间消耗要少得多，因此这个模式可以大大缩短应用程序获取数据的延迟，同时也能减轻数据库的负载压力。</p></blockquote><p>看到这，我心想这不是和其他本地缓存Guava、Caffeine啥的一样吗，换汤不换药，都是使用的应用服务的内存罢了。要说有什么好处，可能就是我在项目中能少引入一个中间件了。</p><p>不过，我这点浅薄的猜想，在看完客户端缓存的具体应用模式后，彻底被颠覆了。</p><h3 id="两种模式" tabindex="-1"><a class="header-anchor" href="#两种模式" aria-hidden="true">#</a> 两种模式</h3><p>在了解了客户端缓存的基本功能后，我们来看看它的两种基本应用模式。Redis的客户端缓存支持被称为<code>tracking</code>，个人感觉翻译为对key的<strong>追踪</strong>就很好理解，它具有两种模式：</p><ul><li>默认模式，服务端会记录某个客户端具体访问过哪一些<code>key</code>，当这些<code>key</code>对应的值发生变化时，会发送失效消息给这些客户端。这个模式会在服务端消耗一些内存，但是发送失效消息的范围，被限制在了客户端存储了的<code>key</code>的集合范围内</li><li>广播模式，服务端不会再记录某个客户端访问了哪些<code>key</code>，因此这个模式不消耗服务端的内存。取而代之的是，客户端需要订阅<code>key</code>的特定前缀，每当符合这个前缀的<code>key</code>对应的值发生改变时，客户端都会收到通知消息</li></ul><p>看到这里，它和我们之前使用的两级缓存之间差异，是不是已经初露端倪了呢？如果还不熟悉两级缓存的架构，那么可以先来看看下面的这张图：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4983fe6cf0a5424b9c2c302f8b1d0596~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这种架构在理论上看起来不错，但是实际使用起来需要注意的点不少，尤其是在分布式模式下，需要保证各个主机下的一级缓存的一致性问题，回想一下我们原先的解决方案，可以使用redis本身的<strong>发布/订阅</strong>功能来实现：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa247ca137fc4060bd7f5cff5b65c211~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>而客户端缓存的出现，大大简化了这一过程。我们以<strong>默认模式</strong>为例，看一下使用了客户端缓存后的操作过程：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e966424b634442ab878a7fa117c44e56~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>相比原先的发布/订阅模式，我们可以看到明显的优势，使用客户端缓存功能后，我们只需要单纯的修改redis中的数据就可以了，手动处理发布/订阅消息的这一过程可以完全被省略。</p><h3 id="优势" tabindex="-1"><a class="header-anchor" href="#优势" aria-hidden="true">#</a> 优势</h3><p>到这里，在了解了客户端缓存的基本功能与两种模式后，我们来对比一下，和传统的只使用redis做远程缓存、以及使用整合后的两级缓存相比较，客户端缓存具有什么样的优势。</p><ul><li>当应用的服务端存在缓存时，会直接读取本地缓存，能够减少网络访问上造成的延迟，从而加快访问速度</li><li>同时也能减少访问redis服务端的次数，降低redis的负载压力</li><li>在分布式环境下，不再需要通过发布订阅来通知其他主机更新本地缓存，来保证数据的一致性。使用客户端缓存后，它所具有的原生的消息通知功能，能很好地支持作废本地缓存，保证之后访问时能取到更新后的新数据</li></ul><h3 id="误区" tabindex="-1"><a class="header-anchor" href="#误区" aria-hidden="true">#</a> 误区</h3><p>在开始演示客户端缓存的使用之前，我们先来纠正一个误区。</p><p>虽然这个新特性被称为<strong>客户端缓存</strong>，但是redis本身不提供在应用服务端缓存数据的功能，这个功能要由<strong>访问redis的客户端</strong>自己去实现。</p><p>说白了，也就是redis服务端只负责通知你，你缓存在应用服务本地的这个key已经作废了，至于你本地如何缓存的这些数据，redis并不关心，也不负责。</p><h2 id="功能演示" tabindex="-1"><a class="header-anchor" href="#功能演示" aria-hidden="true">#</a> 功能演示</h2>',25),g=e("code",null,"Redis6.x",-1),u={href:"https://mp.weixin.qq.com/s/-UGsYhz3hFEWeme-LlTk-g",target:"_blank",rel:"noopener noreferrer"},f={href:"https://mp.weixin.qq.com/s/rLk2EW0TKAIkQvx1WefafA",target:"_blank",rel:"noopener noreferrer"},b=d(`<p>首先做一下准备工作，通过<code>telnet</code>连接redis服务，并切换到<code>resp3</code>协议模式：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>telnet <span class="token number">127.0</span>.0.1 <span class="token number">6379</span>
hello <span class="token number">3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1、默认模式" tabindex="-1"><a class="header-anchor" href="#_1、默认模式" aria-hidden="true">#</a> 1、默认模式</h3><p>在使用客户端连接到redis服务后，需要先通过指令开启<code>tracking</code>模式的功能，因为在客户端连接后这个选项是默认关闭的，会无法收到失效类型的<code>push</code>消息：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#开启</span>
client tracking on
<span class="token comment">#关闭</span>
client tracking off
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当开启<code>tracking</code>后的默认模式下，redis服务端会记录每个客户端请求过的key，当key对应的值发生变化时，会发送失效信息给客户端。简单总结一下，也就是说这个模式能够生效的<strong>必要前提条件</strong>有两个：</p><ul><li>开启<code>tracking</code></li><li>客户端访问过某个key</li></ul><p>下面我们还是在<code>telnet</code>中来模拟一下这个过程，分别启动两个redis客户端，在client1中先执行<code>get</code>命令后，再在client2对相同的key执行<code>set</code>操作修改它的值，之后就会在client1中收到<code>push</code>类型的消息。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a848a93753184a8eaf099943de48048a~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>push</code>类型的消息我们在RESP3中介绍过了，这里简单再唠叨两句：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span><span class="token number">2</span>
<span class="token variable">$10</span>
invalidate
*1
<span class="token variable">$4</span>
user
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>起始的第一字节<code>&gt;</code>表示该消息为<code>push</code>类型，后面消息体中包含了两部分内容，第一部分表示收到的消息类型为<code>invalidate</code>，也就是作废类型的信息，第二部分则是需要作废的key是<code>user</code>。</p><p>除此之外，当一个缓存的key到达失效时间导致过期，或是因为到达最大内存，要使用驱逐策略进行驱逐时，也会对客户端发送<code>PUSH</code>的消息。下面以缓存的key过期为例：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ff2114485c642fbbb7a46a3e233ffaf~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>另外，对于单个key来说，这个<code>tracking</code>消息只会对客户端发送一次，当第二次修改该key所对应的值后，客户端不会再收到<code>tracking</code>的消息。只有对这个key再执行一次<code>get</code>命令，之后才会再次收到<code>tracking</code>消息。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c62ae02f869045d9a98b2b73bc231766~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>默认模式虽然使用起来简单，但是需要在服务端存储客户端的访问数据，记录哪些key被哪些客户端访问过。如果访问的不是少量的热点数据的话，可能会占用大量redis服务端的内存空间。应对这种情况，可以试一试下面要介绍的广播模式。</p><h3 id="_2、广播模式" tabindex="-1"><a class="header-anchor" href="#_2、广播模式" aria-hidden="true">#</a> 2、广播模式</h3><p>在广播模式<code>BCAST</code>下，redis服务端不再记录key的访问情况，而是无差别地向所有开启<code>tracking</code>广播的客户端发送消息。这样一来，好处就是不需要浪费redis服务端的内存进行记录，但是坏处就是客户端可能会收到过多的消息，其中可能还会包含自己不需要的一些key。</p><p>在使用前，需要先通过命令开启广播模式：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>client tracking on bcast
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>下面，我们通过一个例子来进行广播模式的使用演示：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96c737d305d84909bb52fe3241286ff7~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到在开启广播模式后，只要在client2中修改了key对应的值，在client1中都会收到作废消息，而不管client1之前在本地是否进行过缓存。</p><p>并且，另外一点和默认模式不同的是，广播模式是能够重复多次收到一个key的失效消息的，因为服务端没有记录，所以只要有key发生了修改，客户端就会收到失效消息。</p><p>这时候，有的小伙伴可能就要问了，如果我不想收到这么多没用的冗余消息，有没有什么办法进行一下过滤或精简呢？</p><p>答案是可以的，在广播模式下，客户端可以只关注一些<strong>特定前缀</strong>的key，表示我只需要接收这些前缀的key，其他的就不要发给我了。命令格式如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>client tracking on bcast prefix myprefix
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再来看一下使用过程的示例：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e09436b27f444f48aae9fe1da8cb1cbd~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到，在设置了只关注以<code>order:</code>作为前缀的key后，成功过滤掉了<code>user</code>的失效消息。从这个角度来看，也要求了我们在缓存一个类型的数据时，都以相同的单词作为前缀，规范了我们在使用缓存中对key的命名规则。</p><p>至于在业务中具体要使用哪种模式，可能更多的需要进行一下权衡。看一下你究竟是能忍受占用更多redis服务端的内存，还是能够忍受收到大量不需要的失效消息。</p><h3 id="_3、转发模式" tabindex="-1"><a class="header-anchor" href="#_3、转发模式" aria-hidden="true">#</a> 3、转发模式</h3><p>默认模式和广播模式的生效，都要在开启<code>RESP3</code>协议的前提下，具体原因看过上面的例子大家应该也都清楚了，因为要使用<code>tracking</code>的话，就必须要借助到<code>RESP3</code>协议中的新的<code>push</code>消息类型。</p><p>那么如果客户端还是使用的旧版本<code>RESP V2</code>的话，也想要体验这一功能，应该如何进行改造呢？</p><p>不得不说redis6的开发者想的还是蛮全面的，为了适配<code>RESP V2</code>，专门设计了一种新的<strong>转发模式</strong>，允许使用旧版本协议的客户端通过<code>Pub/Sub</code>发布订阅功能来接收key的失效信息。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dffb380d01bd44edbf0971af403d1a7c~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从上面这张图可以看到，转发模式的核心就是redis服务端会将原先<code>push</code>类型的<code>tracking</code>信息，转发到订阅了<code>_redis_:invalidate</code>这一信道的被指定的客户端上。</p><p>我们来梳理一下上面的流程，首先在client1需要使用指令开启转发模式：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>client tracking on bcast redirect <span class="token punctuation">[</span>client-id<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>相对广播模式，多了两个参数，<code>redirect</code>表示为转发模式，后面的<code>client-id</code>表示消息要发送给哪一个客户端，客户端的id可以在client2上通过<code>client id</code>指令获取。</p><p>在client2中，则需要订阅指定的信道：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>subscribe _redis_:invalidate
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其实说白了，转发模式还是使用的发布订阅功能罢了，只不过redis帮我们解放了双手，把发送消息的工作由自己完成了。整个操作的流程如下图所示：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b01e47f8d3f24cef8a3420ec64f040fe~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到，client2中收到的消息格式与之前的<code>push</code>类型消息不同，是一条RESP V2中多条批量回复格式的消息，表示的含义同样是收到的key已经作废掉了。</p><p>需要注意的是，虽然说开启转发模式的指令中也带了一个<code>bcast</code>，但是它和广播模式有着非常大的区别。在转发模式下，<code>key</code>的作废消息只能被转发到一个客户端上，如果先后执行两条指定转发指令，那么后执行的指令会覆盖前一指令中转发的<code>client-id</code>。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c731aaeee3c14807b3860ae907f094a0~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>看到这里是不是多少感觉这个转发模式有点鸡肋，毕竟实际的业务场景中很有可能会有多个客户端的存在，只能转发一个实在是有点说不过去了。不过，也有可能作者就是这么设计，留点缺陷，好让大家更快地拥抱<code>RESP3</code>……</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>好啦，到这里客户端缓存的基本理论和使用就介绍的差不多了，不得不说，Redis6的这个新特性确实给了我们眼前一亮的感觉。从这个新特性也可以看出，Redis大有把缓存从服务端的局限中挣脱出来，染指向客户端，一统缓存江湖的意味。</p><p>不过这个过程应该并不简单，就像我们前面说的，毕竟只有Redis服务端还不够，还需要优秀的客户端进行支持才行。</p><p>那么下一篇文章，我们就来从实战角度，看看如何改造客户端，让<code>client-side caching</code>能在项目中落地开花。</p><p>这次的分享就到这里，我是Hydra，下篇文章再见。</p>`,54),h=e("p",null,"官方文档：",-1),m={href:"https://redis.io/docs/manual/client-side-caching/",target:"_blank",rel:"noopener noreferrer"};function k(v,y){const a=p("ExternalLinkIcon");return o(),s("div",null,[t(" more "),l,e("p",null,[i("下面将通过一些实例来进行演示，本文代码的运行前提条件是你已经装好了"),g,i("版本，linux环境下可以直接从官网下载后编译安装，windows环境下的安装可以参考 "),e("a",u,[i("手摸手教你在Windows环境下运行Redis6.x"),c(a)]),i(" 这篇文章。")]),e("p",null,[i("概念上的东西我们也大体了解了，下面我们分别来看一下客户端缓存具体实现的三种模式（至于为什么多了一种，后面再来细说）。在正式开始前，强烈建议大家先花个十几分钟了解一下 "),e("a",f,[i("Redis6底层的通信协议RESP3"),c(a)]),i("，否则在看到具体的通信内容时可能会存在一些疑问。")]),b,e("blockquote",null,[h,e("p",null,[e("a",m,[i("https://redis.io/docs/manual/client-side-caching/"),c(a)])])])])}const _=n(r,[["render",k],["__file","clientSideCaching.html.vue"]]);export{_ as default};
