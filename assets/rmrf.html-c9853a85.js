import{_ as n,W as o,X as c,$ as d,Y as e,a0 as a,a1 as t,Z as p,C as i}from"./framework-9e67db09.js";const l={},r=p(`<p>事情是这样的，前几天隔壁部门的哥们在生产环境的数据库上，执行了一下<code>drop</code>命令，好嘛，活生生的删库跑路的例子居然真的在我身边发生了，好在运维同学给力，后来恢复了数据。事后听说这哥们虽然没被开除，但也吃了个公司的警告。</p><p>再然后，运维那边回收了所有环境下数据库的<code>drop</code>命令的权限，甚至包括了开发环境，本来觉得对我们也没啥影响，一般我们也没有啥需要删表的需求。但是隔了没几天，我在重命名一个表的时候，突然弹出了这样一个报错：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29dfd8d7b5a1443d93e2c83cc6fe55e6~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>仔细看了一眼报错：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">1142</span> - DROP <span class="token builtin class-name">command</span> denied to user <span class="token string">&#39;hydra&#39;</span>@<span class="token string">&#39;localhost&#39;</span> <span class="token keyword">for</span> table <span class="token string">&#39;t_orders&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>什么情况，重命名表和<code>drop</code>命令还有什么关系？本着怀疑的态度，就想探究一下没有<code>drop</code>权限后，对我们的日常数据库操作都有什么影响，于是就有了后面一系列在本地进行的测试。</p><p>首先需要一个没有<code>drop</code>权限的mysql用户，我们先在本地环境使用root用户登录mysql，取消用户hydra的<code>drop</code>权限。和<code>grant</code>授权命令相对应的，可以使用<code>revoke</code>命令取消对用户的授权：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">revoke</span> <span class="token keyword">drop</span> <span class="token keyword">on</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">from</span> hydra<span class="token variable">@&#39;localhost&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>好了，准备工作做完了，It&#39;s show time~</p><h3 id="修改表名" tabindex="-1"><a class="header-anchor" href="#修改表名" aria-hidden="true">#</a> 修改表名</h3><p>前面直接使用navicat来修改表名失败，那我们再用sql命令来尝试一下：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13dd8f2ea2df4b878dea83e2abda0d9f~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上面测试了两种重命名表的命令，无论是<code>ALTER</code>还是<code>RENAME</code>都不能正常使用，看来<code>drop</code>的权限确实会对修改表名造成影响。至于重命名失败的原因，看一下官方文档的说明：</p><blockquote><p>RENAME TABLE renames one or more tables. You must have ALTER and DROP privileges for the original table, and CREATE and INSERT privileges for the new table.</p></blockquote><p>简单来说就是在重命名表时，必须有原始表的<code>ALTER</code>和<code>DROP</code>权限，以及新表的<code>CREATE</code>和<code>INSERT</code>权限。</p><h3 id="truncate" tabindex="-1"><a class="header-anchor" href="#truncate" aria-hidden="true">#</a> truncate</h3><p>当我需要清空一张表、顺带把<code>AUTO_INCREMENT</code>的主键置为初始值时，突然发现<code>truncate</code>命令也无法执行了：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4f58f1bda8c4a1d88e5146ad66ca8f1~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>有了上面的经验，还是看一下官方文档的说明：</p><blockquote><p>Although TRUNCATE TABLE is similar to DELETE, it is classified as a DDL statement rather than a DML statement. It differs from DELETE in the following ways:</p><p>Truncate operations drop and re-create the table, which is much faster than deleting rows one by one, particularly for large tables.</p></blockquote><p>文档给出的解释是尽管<code>truncate</code>和<code>delete</code>的功能很像，但是<code>truncate</code>被归类为DDL语言，而<code>delete</code>则是DML语言。相对于<code>delete</code>一行行删除数据，<code>truncate</code>会<strong>删除</strong>表后重新<strong>新建表</strong>，这一操作相对<code>delete</code>会快很多，尤其是对大表而言。</p><p>从分类也可以看出两者之间的不同，DML(<code>data manipulation language</code>)作为数据操作语言，主要是针对数据进行一些操作，例如常用的增删改查。而DDL(<code>data definition language</code>)则是数据定义语言，主要应用于定义或改变表的结构等操作，并且这一操作过程是隐性提交的，不能回滚。</p><p>在<code>truncate</code>无法使用的情况下，来执行一下<code>delete</code>试试：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06980e38bb5d425c96f5d6e2a6ab2efd~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>虽然说不带<code>where</code>条件的<code>delete</code>删除语句很不推荐使用，但是在功能上还是可以执行成功的。那么再看看另一个问题，表中的自增<code>id</code>重置了吗？</p><p>我们知道，如果执行了<code>truncate</code>的话，那么自增列<code>id</code>的值会被重置为1。下面看看<code>delete</code>执行后的情况，插入一条数据并查询：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9ebbd0999484472b387c87d64c0d93c~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>通过上面的结果，可以看到使用<code>delete</code>清表后，自增列的值还是在原先的基础上进行自增。如果需要重置这个值的话，需要我们手动在表上执行<code>alter</code>命令修改：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">alter</span> <span class="token keyword">table</span> t_orders <span class="token keyword">auto_increment</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="drop作用范围" tabindex="-1"><a class="header-anchor" href="#drop作用范围" aria-hidden="true">#</a> drop作用范围</h3><p>那么，是否存在即使在没有权限的情况下，也可以执行成功的<code>drop</code>指令？我们对不同对象分别进行测试，首先尝试对数据库、表、视图的<code>drop</code>操作：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">drop</span> <span class="token keyword">DATABASE</span> mall<span class="token punctuation">;</span>
<span class="token operator">&gt;</span> <span class="token number">1044</span> <span class="token operator">-</span> Access denied <span class="token keyword">for</span> <span class="token keyword">user</span> <span class="token string">&#39;hydra&#39;</span><span class="token variable">@&#39;localhost&#39;</span> <span class="token keyword">to</span> <span class="token keyword">database</span> <span class="token string">&#39;mall&#39;</span>
<span class="token operator">&gt;</span> 时间: <span class="token number">0.005</span>s

<span class="token keyword">drop</span> <span class="token keyword">TABLE</span> t_orders<span class="token punctuation">;</span>
<span class="token operator">&gt;</span> <span class="token number">1142</span> <span class="token operator">-</span> <span class="token keyword">DROP</span> command denied <span class="token keyword">to</span> <span class="token keyword">user</span> <span class="token string">&#39;hydra&#39;</span><span class="token variable">@&#39;localhost&#39;</span> <span class="token keyword">for</span> <span class="token keyword">table</span> <span class="token string">&#39;t_orders&#39;</span>
<span class="token operator">&gt;</span> 时间: <span class="token number">0</span>s

<span class="token keyword">drop</span> <span class="token keyword">VIEW</span> order_view<span class="token punctuation">;</span>
<span class="token operator">&gt;</span> <span class="token number">1142</span> <span class="token operator">-</span> <span class="token keyword">DROP</span> command denied <span class="token keyword">to</span> <span class="token keyword">user</span> <span class="token string">&#39;hydra&#39;</span><span class="token variable">@&#39;localhost&#39;</span> <span class="token keyword">for</span> <span class="token keyword">table</span> <span class="token string">&#39;order_view&#39;</span>
<span class="token operator">&gt;</span> 时间: <span class="token number">0.001</span>s
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这些命令理所当然的没有执行成功，但是在尝试到使用<code>drop</code>删除存储过程时，意料之外的结果出现了。在没有<code>drop</code>权限的情况下，对存储过程的<code>drop</code>操作，居然可以执行成功：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d479cbec3bc49f583f4d2e7b0460470~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>翻到官方文档中授权这一章节，看一下这张图就明白了：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/957c4bfab04649dab3ba7b62190f619d~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上面的表进行了解释，<code>drop</code>命令的作用范围仅仅是数据库、表以及视图，而存储过程的权限被单独放在<code>alter routine</code>中了，因此即使没有<code>drop</code>权限，我们仍可以用<code>drop</code>命令来删除存储过程。</p><h3 id="delete后如何恢复数据" tabindex="-1"><a class="header-anchor" href="#delete后如何恢复数据" aria-hidden="true">#</a> delete后如何恢复数据</h3><p>通过前面的实验可以看到，虽然在回收<code>drop</code>权限后不能使用<code>truncate</code>清空数据表了，但我们仍然可以使用<code>delete</code>语句达到相同的效果，那么为什么<code>delete</code>就不害怕删库的风险呢？</p><p>前面我们提到过，<code>delete</code>语句属于DML语言，其实在实际的删除过程中是一行行的进行删除的，并且会将每行数据的删除日志记录在日志中，下面我们就看看如何利用<code>binlog</code>来恢复删除的数据。</p><p>首先要求数据库开启<code>binlog</code>，使用下面的语句来查询是否开启：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">&#39;%log_bin%&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在值为<code>ON</code>的情况下，表示开启了<code>binglog</code>：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d29fecc67aa046cdb63065ffb05386cf~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>确保开启了<code>binlog</code>后，我们使用<code>delete</code>来删除表中的全部数据：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">delete</span> <span class="token keyword">from</span> t_orders<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在恢复删除的数据前，需要先找到存放数据文件的目录：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/652166f391d14fd284b1e8b01db50695~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在该目录下，存在若干名称为<code>mysql-bin.*****</code>的文件，我们需要根据删除操作发生的时间找到临近的<code>binglog</code>文件：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c26a22274b645298426934b7ef8255b~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>找到目标<code>binlog</code>文件后，这里先将它拷贝到<code>D:\\tmp</code>目录下，然后到mysql安装目录的<code>bin</code>目录下，执行下面的指令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>mysqlbinlog --base64-output<span class="token operator">=</span>decode-rows <span class="token parameter variable">-v</span> <span class="token parameter variable">--database</span><span class="token operator">=</span>mall --start-datetime<span class="token operator">=</span><span class="token string">&quot;2021-09-17 20:50:00&quot;</span> --stop-datetime<span class="token operator">=</span><span class="token string">&quot;2021-09-17 21:30:00&quot;</span> D:<span class="token punctuation">\\</span>tmp<span class="token punctuation">\\</span>mysql-bin.000001 <span class="token operator">&gt;</span> mysqllog.sql
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对参数进行一下说明：</p><ul><li><code>base64-output=decode-rows</code>：基于行事件解析成sql语句，并将数据转换正常的字符</li><li><code>database</code>：数据库名</li><li><code>start-datetime</code>：从binlog中第一个等于或晚于该时间戳的事件开始读取，也就是恢复数据的起始时间</li><li><code>stop-datetime</code>：与上面对应的，是恢复数据的结束时间</li><li><code>D:\\tmp\\mysql-bin.000001</code>：恢复数据的日志文件</li><li><code>mysqllog.sql</code>：恢复数据的输出文件</li></ul><p>执行完成后，在<code>bin</code>目录下会生成一个<code>mysqllog.sql</code>的文件，打开文件看一下，可以找到删除时执行的<code>delete</code>语句：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b2fd7e49b8548348368f981a730c5ac~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从语句中可以拿到<code>delete</code>命令执行时每一行数据的值，这样就可以进行数据的恢复了。如果需要恢复的数据量非常大的话，建议使用脚本批量将<code>delete</code>语句转换为<code>insert</code>语句，减轻恢复数据的工作量。</p><p>好了，如果你坚持看到这里，答应我，以后删库前，先看一下有没有开启binlog好吗？</p>`,58),u={href:"https://dev.mysql.com/doc/refman/5.7/en",target:"_blank",rel:"noopener noreferrer"};function g(b,m){const s=i("ExternalLinkIcon");return o(),c("div",null,[d(" more "),r,e("blockquote",null,[e("p",null,[a("官方文档："),e("a",u,[a("https://dev.mysql.com/doc/refman/5.7/en"),t(s)])])])])}const f=n(l,[["render",g],["__file","rmrf.html.vue"]]);export{f as default};
