import{_ as n,W as s,X as a,$ as e,Z as p}from"./framework-9e67db09.js";const t={},o=p(`<p>首先看一下这道常见的面试题，下面代码中，会创建几个字符串对象？</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> s<span class="token operator">=</span><span class="token string">&quot;a&quot;</span><span class="token operator">+</span><span class="token string">&quot;b&quot;</span><span class="token operator">+</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果你比较一下Java源代码和反编译后的字节码文件，就可以直观的看到答案，只创建了一个String对象。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea50f5dc4ef14c6db24bed239f0a6f0a~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>估计大家会有疑问了，为什么源代码中字符串拼接的操作，在编译完成后会消失，直接呈现为一个拼接后的完整字符串呢？</p><p>这是因为在编译期间，应用了编译器优化中一种被称为<strong>常量折叠</strong>(Constant Folding)的技术，会将<strong>编译期常量</strong>的加减乘除的运算过程在编译过程中折叠。编译器通过语法分析，会将常量表达式计算求值，并用求出的值来替换表达式，而不必等到运行期间再进行运算处理，从而在运行期间节省处理器资源。</p><p>而上边提到的<strong>编译期常量</strong>的特点就是它的值在编译期就可以确定，并且需要完整满足下面的要求，才可能是一个编译期常量：</p><ul><li>被声明为<code>final</code></li><li>基本类型或者字符串类型</li><li>声明时就已经初始化</li><li>使用常量表达式进行初始化</li></ul><p>上面的前两条比较容易理解，需要注意的是第三和第四条，通过下面的例子进行说明：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">String</span> s1<span class="token operator">=</span><span class="token string">&quot;hello &quot;</span><span class="token operator">+</span><span class="token string">&quot;Hydra&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">final</span> <span class="token class-name">String</span> s2<span class="token operator">=</span><span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">&quot;Hydra&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>编译器能够在编译期就得到<code>s1</code>的值是<code>hello Hydra</code>，不需要等到程序的运行期间，因此<code>s1</code>属于编译期常量。而对<code>s2</code>来说，虽然也被声明为<code>final</code>类型，并且在声明时就已经初始化，但使用的不是常量表达式，因此不属于编译期常量，这一类型的常量被称为<strong>运行时常量</strong>。再看一下编译后的字节码文件中的常量池区域：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86ce9586bb944f7fbcf94faedb69d6bf~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到常量池中只有一个<code>String</code>类型的常量<code>hello Hydra</code>，而<code>s2</code>对应的字符串常量则不在此区域。对编译器来说，运行时常量在编译期间无法进行折叠，编译器只会对尝试修改它的操作进行报错处理。</p><p>另外值得一提的是，编译期常量与运行时常量的另一个不同就是是否需要对类进行初始化，下面通过两个例子进行对比：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IntTest1</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a1<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> a1<span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;init class&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行上面的代码，输出：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>init class
<span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果对上面进行修改，对变量<code>a</code>添加<code>final</code>进行修饰：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再次执行上面的代码，会输出：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以看到在添加了<code>final</code>修饰后，两次运行的结果是不同的，这是因为在添加<code>final</code>后，变量<code>a</code>成为了编译期常量，不会导致类的初始化。另外，在声明编译器常量时，<code>final</code>关键字是必要的，而<code>static</code>关键字是非必要的，上面加<code>static</code>修饰只是为了验证类是否被初始化过。</p><p>我们再看几个例子来加深对<code>final</code>关键字的理解，运行下面的代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">String</span> h1 <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> h2 <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> s1 <span class="token operator">=</span> h1 <span class="token operator">+</span> <span class="token string">&quot;Hydra&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> s2 <span class="token operator">=</span> h2 <span class="token operator">+</span> <span class="token string">&quot;Hydra&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> <span class="token string">&quot;helloHydra&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s2 <span class="token operator">==</span> <span class="token string">&quot;helloHydra&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行结果：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token boolean">true</span>
<span class="token boolean">false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>代码中字符串<code>h1</code>和<code>h2</code>都使用常量赋值，区别在于是否使用了<code>final</code>进行修饰，对比编译后的代码，<code>s1</code>进行了折叠而<code>s2</code>没有，可以印证上面的理论，<code>final</code>修饰的字符串变量属于编译期常量。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e73583159dc49e09749e4f5075032a4~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>再看一段代码，执行下面的程序，结果会返回什么呢？</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> h <span class="token operator">=</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">String</span> h2 <span class="token operator">=</span> h<span class="token punctuation">;</span>
    <span class="token class-name">String</span> s <span class="token operator">=</span> h2 <span class="token operator">+</span> <span class="token string">&quot;Hydra&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token operator">==</span><span class="token string">&quot;helloHydra&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>答案是<code>false</code>，因为虽然这里字符串<code>h2</code>被<code>final</code>修饰，但是初始化时没有使用编译期常量，因此它也不是编译期常量。</p><p>在上面的一些例子中，在执行常量折叠的过程中都遵循了<strong>使用常量表达式进行初始化</strong>这一原则，这里可能有的同学还会有疑问，到底什么样才能算得上是常量表达式呢？在<code>Oracle</code>官网的文档中，列举了很多种情况，下面对常见的情况进行列举（除了下面这些之外官方文档上还列举了不少情况，如果有兴趣的话，可以自己查看）：</p><ul><li>基本类型和String类型的字面量</li><li>基本类型和String类型的强制类型转换</li><li>使用<code>+</code>或<code>-</code>或<code>!</code>等一元运算符（不包括<code>++</code>和<code>--</code>）进行计算</li><li>使用加减运算符<code>+</code>、<code>-</code>，乘除运算符<code>*</code>、 <code>/</code> 、<code>%</code> 进行计算</li><li>使用移位运算符 <code>&gt;&gt;</code>、 <code>&lt;&lt;</code>、 <code>&gt;&gt;&gt;</code>进行位移操作</li><li>……</li></ul><p>字面量（literals）是用于表达源代码中一个固定值的表示法，在Java中创建一个对象时需要使用<code>new</code>关键字，但是给一个基本类型变量赋值时不需要使用<code>new</code>关键字，这种方式就可以被称为字面量。Java中字面量主要包括了以下类型的字面量：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//整数型字面量：</span>
<span class="token keyword">long</span> l<span class="token operator">=</span><span class="token number">1L</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">//浮点类型字面量：</span>
<span class="token keyword">float</span> f<span class="token operator">=</span><span class="token number">11.1f</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> d<span class="token operator">=</span><span class="token number">11.1</span><span class="token punctuation">;</span>

<span class="token comment">//字符和字符串类型字面量：</span>
<span class="token keyword">char</span> c<span class="token operator">=</span><span class="token char">&#39;h&#39;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s<span class="token operator">=</span><span class="token string">&quot;Hydra&quot;</span><span class="token punctuation">;</span>

<span class="token comment">//布尔类型字面量：</span>
<span class="token keyword">boolean</span> b<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们在代码中定义并初始化一个字符串对象后，程序会在常量池（<code>constant pool</code>）中缓存该字符串的字面量，如果后面的代码再次用到这个字符串的字面量，会直接使用常量池中的字符串字面量。</p><p>除此之外，还有一类比较特殊的<code>null</code>类型字面量，这个类型的字面量只有一个就是<code>null</code>，这个字面量可以赋值给任意引用类型的变量，表示这个引用类型变量中保存的地址为空，也就是还没有指向任何有效的对象。</p><p>那么，如果不是使用的常量表达式进行初始化，在变量的初始化过程中引入了其他变量（且没有被<code>final</code>修饰）的话，编译器会怎样进行处理呢？我们下面再看一个例子：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> s1<span class="token operator">=</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> s2<span class="token operator">=</span>s1<span class="token operator">+</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> s3<span class="token operator">=</span><span class="token string">&quot;a&quot;</span><span class="token operator">+</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token operator">==</span><span class="token string">&quot;ab&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3<span class="token operator">==</span><span class="token string">&quot;ab&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果打印：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token boolean">false</span>
<span class="token boolean">true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么会出现不同的结果？在Java中，String类型在使用<code>==</code>进行比较时，是判断的引用是否指向堆内存中的同一块地址，出现上面的结果那么说明指向的不是内存中的同一块地址。</p><p>通过之前的分析，我们知道<code>s3</code>会进行常量折叠，引用的是常量池中的<code>ab</code>，所以相等。而字符串<code>s2</code>在进行拼接时，表达式中引用了其他对象，不属于编译期常量，因此不能进行折叠。</p><p>那么，在没有常量折叠的情况下，为什么最后返回的是<code>false</code>呢？我们看一下这种情况下，编译器是如何实现，先执行下面的代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> s1<span class="token operator">=</span><span class="token string">&quot;my &quot;</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> s2<span class="token operator">=</span><span class="token string">&quot;name &quot;</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> s3<span class="token operator">=</span><span class="token string">&quot;is &quot;</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> s4<span class="token operator">=</span><span class="token string">&quot;Hydra&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> s<span class="token operator">=</span>s1<span class="token operator">+</span>s2<span class="token operator">+</span>s3<span class="token operator">+</span>s4<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后使用<code>javap</code>对字节码文件进行反编译，可以看到在这一过程中，编译器同样会进行优化：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c47d52e831042a988007ef601bd28e1~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到，虽然我们在代码中没有显示的调用<code>StringBuilder</code>，但是在字符串拼接的场景下，Java编译器会自动进行优化，新建一个<code>StringBuilder</code>对象，然后调用<code>append</code>方法进行字符串的拼接。而在最后，调用了<code>StringBuilder</code>的<code>toString</code>方法，生成了一个新的字符串对象，而不是引用的常量池中的常量。这样，也就能解释为什么在上面的例子中，<code>s2==&quot;ab&quot;</code>会返回<code>false</code>了。</p><blockquote><p>本文代码基于Java 1.8.0_261-b12 版本测试</p></blockquote>`,49);function c(l,i){return s(),a("div",null,[e(" more "),o])}const d=n(t,[["render",c],["__file","stringappend.html.vue"]]);export{d as default};
