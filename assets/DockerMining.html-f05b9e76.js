import{_ as e,W as a,X as s,$ as n,Z as c}from"./framework-9e67db09.js";const r={},p=c(`<p>事情是这样的，前段时间的周末刚在外面坐下准备吃个饭，突然收到一条短信：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1b21fffa39248efa298ab41cf99122a~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>什么情况？我一个小小的个人服务器都能被挖矿？回想了一下，也没想到之前做了什么能引起被挖矿的操作啊，直到两个小时后，又收到一条短信报警：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90d2eff674c441d9815313e48193f9f2~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>端口？提到端口我想起来了，自己前一天因为要用idea连接服务器上的docker，开启了一个2375的端口。至于具体操作，就是简单修改了一下配置文件<code>/usr/lib/systemd/system/docker.service/usr/lib/systemd/system/docker.servicevv</code>，修改了下面的内容：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token assign-left variable">ExecStart</span><span class="token operator">=</span>/usr/bin/dockerd <span class="token parameter variable">-H</span> fd:// <span class="token parameter variable">--containerd</span><span class="token operator">=</span>/run/containerd/containerd.sock
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在这句后面添加了一句：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token parameter variable">-H</span> tcp://0.0.0.0:2375
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样，就开启了一个2375端口，通过这个端口，可以在idea中配置docker，并在打包的同时进行镜像的上传：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02b13c01c24d4dd08071552554980a00~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>通过这个端口，我们就可以直接对远程的<code>docker daemon</code>进行操作了。</p><h2 id="紧急处理" tabindex="-1"><a class="header-anchor" href="#紧急处理" aria-hidden="true">#</a> 紧急处理</h2><p>既然找到了问题所在，那我们就得立马处理这个问题了。回到家，马上在安全配置里关闭了2375端口的外网访问：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/741c7d3ee3af48788c08bc8aefdd0f45~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>再看一下后台的报警信息：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e36b6e8ef017480087bda023ef0fa539~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>使用<code>kill</code>命令杀死这个进程：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07d2f9fb2b694c66bd07134b0c575c5b~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>好了，这下进程也杀死了，外网的端口访问也关闭了，应该没事了吧？没想到晚上7点多，又连着报了两条警告信息：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5446301ae7df4cffb3791db2be470e76~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bc4912eefe14bf59cefbbdc552959e6~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>使用<code>ps</code>指令看一下13102进程，没有查到。查一下<code>masscan</code>进程，能够找到，这个<code>masscan</code>是一个端口扫描工具，能够根据IP地址的范围和端口号，快速进行端口扫描：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c55640891b414da3a351d8aba2828af5~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>顺便查询了下父进程的<code>pid</code>，居然使用了<code>portainer</code>，居然连docker的图形化管理界面都帮我安装上了。需要注意的是在杀死<code>masscan</code>进程前，一定要杀死父进程，否则<code>masscan</code>进程会不断重启。</p><p>再看一下第二个报警的32452进程，能够找到<code>docker-cache</code>进程，使用<code>kill</code>杀死后不会进行重启。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b66dc118a754b7abe04df2af47d7cbd~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>停止运行的容器并删除：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28c91f03f2a04e608a4bc19bf720f05b~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>删除挖矿<code>image</code>：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/409227faa37442788512b544d12d5aa0~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>修改配置文件，删掉2375端口的<code>tcp</code>连接，然后重启docker：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>systemctl daemon-reload
systemctl  start <span class="token function">docker</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="入侵原理" tabindex="-1"><a class="header-anchor" href="#入侵原理" aria-hidden="true">#</a> 入侵原理</h2><p>到这，先总结一下为什么能够通过2375端口入侵宿主主机？</p><ul><li>docker对<code>user namespace</code>没有做隔离，也就是说，容器内部的<code>root</code>用户就是宿主机的<code>root</code>用户，一旦挂载目录，就可以在容器内部以宿主机的<code>root</code>用户身份对挂载的文件系统随意修改了</li><li>docker服务拥有很高的执行权利(相当于<code>root</code>)，并且在docker用户组下的普通用户不需要任何其他验证就可以执行<code>docker run</code>等命令</li><li>而暴露的<code>docker remote</code> API端口如果没有启动<code>ssl</code>验证的话，任何能连通到这台docker宿主机的的机器都可以随意操作这台docker宿主机的<code>docker daemon</code></li></ul><h2 id="漏洞修复" tabindex="-1"><a class="header-anchor" href="#漏洞修复" aria-hidden="true">#</a> 漏洞修复</h2><p>那么应该如何修复这个漏洞呢，通过查阅资料，docker本身提供了加密的远程管理端口2376，配合CA证书，就能提供<code>TLS</code>连接了。</p><p>首先要准备5个证书和秘钥文件，分别是<code>ca.pem</code>、<code>server-cert.pem</code>、<code>server-key.pem</code>、<code>client-cert.pem</code>和<code>client-key.pem</code>。其中，<code>server-cert.pem</code>中限制了能够访问Docker主机的客户端列表。</p><p>启动<code>docker deamon</code>时，需要设置<code>-H</code>、<code>–tls</code>、<code>–tlscacert=ca.pem</code>、<code>–tlscert=server-cert.pem</code>和<code>–tlskey=server-key.pem</code>。此时，只有客户端列表中的主机能够访问docker主机。</p><p>1.生成CA私钥<code>ca-key.pem</code>，使用该私钥对CA证书签名</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>openssl genrsa <span class="token parameter variable">-out</span> ~/docker/ca-key.pem <span class="token number">4096</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2.使用CA私钥生成自签名CA证书<code>ca.pem</code>。生成证书时，通过<code>-days 365</code>设置证书的有效期。单位为天，默认情况下为30天</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>openssl req <span class="token parameter variable">-x509</span> <span class="token parameter variable">-sha256</span> <span class="token parameter variable">-batch</span> <span class="token parameter variable">-subj</span> <span class="token string">&#39;/C=CN/ST=Sichuan/L=Chengdu/O=Ghostcloud Co.,Ltd/OU=Laboratory/CN=www.ghostcloud.cn&#39;</span> <span class="token parameter variable">-new</span> <span class="token parameter variable">-days</span> <span class="token number">365</span> <span class="token parameter variable">-key</span> ~/docker/ca-key.pem <span class="token parameter variable">-out</span> ~/docker/ca.pem
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>3.生成服务器私钥<code>server-key.pem</code>和<code>CSR(Certificate Signing Request)server-csr.pem</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>openssl genrsa <span class="token parameter variable">-out</span> ~/docker/server-key.pem <span class="token number">4096</span>
openssl req <span class="token parameter variable">-subj</span> <span class="token string">&#39;/CN=DockerDaemon&#39;</span> <span class="token parameter variable">-sha256</span> <span class="token parameter variable">-new</span> <span class="token parameter variable">-key</span> ~/docker/server-key.pem <span class="token parameter variable">-out</span> ~/docker/server-csr.pem
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>4.使用CA证书生成服务器证书<code>server-cert.pem</code>。TLS连接时，需要限制客户端的IP列表或者域名列表。只有在列表中的客户端才能通过客户端证书访问<code>docker daemon</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">echo</span> subjectAltName <span class="token operator">=</span> IP:127.0.0.1,IP:192.168.1.100 <span class="token operator">&gt;</span> ~/docker/allow.list
openssl x509 <span class="token parameter variable">-req</span> <span class="token parameter variable">-days</span> <span class="token number">365</span> <span class="token parameter variable">-sha256</span> <span class="token parameter variable">-in</span> ~/docker/server-csr.pem <span class="token parameter variable">-CA</span> ~/docker/ca.pem <span class="token parameter variable">-CAkey</span> ~/docker/ca-key.pem <span class="token parameter variable">-CAcreateserial</span> <span class="token parameter variable">-out</span> ~/docker/server-cert.pem <span class="token parameter variable">-extfile</span> ~/docker/allow.list
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>5.生成客户端私钥<code>client-key.pem</code>和<code>CSRclient-csr.pem</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>openssl genrsa <span class="token parameter variable">-out</span> ~/docker/client-key.pem <span class="token number">4096</span>
openssl req <span class="token parameter variable">-subj</span> <span class="token string">&#39;/CN=DockerClient&#39;</span> <span class="token parameter variable">-new</span> <span class="token parameter variable">-key</span> ~/docker/client-key.pem <span class="token parameter variable">-out</span> ~/docker/client-csr.pem
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>6.使用CA证书生成客户端证书<code>client-cert.pem</code>。需要加入<code>extendedKeyUsage</code>选项</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">echo</span> extendedKeyUsage <span class="token operator">=</span> clientAuth <span class="token operator">&gt;</span> ~/docker/options.list
openssl x509 <span class="token parameter variable">-req</span> <span class="token parameter variable">-days</span> <span class="token number">365</span> <span class="token parameter variable">-sha256</span> <span class="token parameter variable">-in</span> ~/docker/client-csr.pem <span class="token parameter variable">-CA</span> ~/docker/ca.pem <span class="token parameter variable">-CAkey</span> ~/docker/ca-key.pem <span class="token parameter variable">-CAcreateserial</span> <span class="token parameter variable">-out</span> ~/docker/client-cert.pem <span class="token parameter variable">-extfile</span> ~/docker/options.list
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>7.成功生成了需要的证书和秘钥，可以删除临时文件</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">rm</span> <span class="token parameter variable">-f</span> ~/docker/server-csr.pem ~/docker/client-csr.pem ~/docker/allow.list ~/docker/options.list
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>8.为了保证证书和私钥的安全，需要修改文件的访问权限</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">chmod</span> 0444 ~/docker/ca.pem ~/docker/server-cert.pem ~/docker/client-cert.pem
<span class="token function">chmod</span> 0400 ~/docker/ca-key.pem ~/docker/server-key.pem ~/docker/client-key.pem
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>9.重启<code>docker daemon</code>，加入<code>ca.pem</code>、<code>server-cert.pem</code>和<code>server-key.pem</code>。<code>-H=0.0.0.0:2376</code>表示<code>docker daemon</code>监听在2376端口</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> daemon <span class="token parameter variable">--tlsverify</span> <span class="token parameter variable">--tlscacert</span><span class="token operator">=~</span>/docker/ca.pem <span class="token parameter variable">--tlscert</span><span class="token operator">=~</span>/docker/server-cert.pem <span class="token parameter variable">--tlskey</span><span class="token operator">=~</span>/docker/server-key.pem <span class="token parameter variable">-H</span><span class="token operator">=</span><span class="token number">0.0</span>.0.0:2376
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>10.在客户端，运行docker命令时，加入<code>ca.pem</code>、<code>client-cert.pem</code>和<code>client-key.pem</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token parameter variable">--tlsverify</span> <span class="token parameter variable">--tlscacert</span><span class="token operator">=~</span>/docker/ca.pem <span class="token parameter variable">--tlscert</span><span class="token operator">=~</span>/docker/client-cert.pem <span class="token parameter variable">--tlskey</span><span class="token operator">=~</span>/docker/client-key.pem <span class="token parameter variable">-H</span><span class="token operator">=</span>tcp://127.0.0.1:2376 info
Containers: <span class="token number">41</span> Running: <span class="token number">16</span> Paused: <span class="token number">0</span> Stopped: <span class="token number">25</span> Images: <span class="token number">821</span> Server Version: <span class="token number">1.10</span>.3 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，就可以安全的远程控制docker主机了。</p>`,60);function o(i,t){return a(),s("div",null,[n(" more "),p])}const l=e(r,[["render",o],["__file","DockerMining.html.vue"]]);export{l as default};
