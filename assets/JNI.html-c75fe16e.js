import{_ as a,W as n,X as s,$ as e,Z as c}from"./framework-9e67db09.js";const o={},i=c(`<p>在前面介绍<code>Unsafe</code>的文章中，简单的提到了java中的本地方法（<code>Native Method</code>），它可以通过JNI（<code>Java Native Interface</code>）调用其他语言中的函数来实现一些相对底层的功能，本文我们就来顺藤摸瓜，介绍一下<code>jni</code>以及它的使用。</p><p>首先回顾一下<code>jni</code>的主要功能，从jdk1.1开始<code>jni</code>标准就成为了java平台的一部分，它提供的一系列的API允许java和其他语言进行交互，实现了在java代码中调用其他语言的函数。通过<code>jni</code>的调用，能够实现这些功能：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fc66bb4b85344099867b5568df103f3~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>通常情况下我们一般使用<code>jni</code>用来调用c或c++中的代码，在上一篇文章中我们用了下面的流程来描述了<code>native</code>方法的调用过程：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">Java</span> <span class="token value attr-value">Code -&gt; JNI -&gt; C/C++ Code</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是准确的来说这一过程并不严谨，因为最终被执行的不是原始的c/c++代码，而是被编译连接后的动态链接库。因此我们将这个过程从单纯的代码调用层面上进行升级，将<code>jni</code>的调用过程提高到了jvm和操作系统的层面，来加点细节进行一下完善：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13a25b74390544898187e5bbdfc457f2~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>看到这里，可能有的小伙伴就要提出疑问了，不是说java语言是跨平台的吗，这种与操作系统本地编译的动态链接库进行的交互，会不会使java失去跨平台的可移植性？</p><p>针对这一问题，大家可以回想一下以前安装jdk的经历，在官网的下载列表中提供了各个操作系统的不同版本jdk，例如<code>windows</code>、<code>linux</code>、<code>mac os</code>版本等等，在这些jdk中，针对不同系统有着不同的jvm实现。而java语言的跨平台性恰好是和它底层的jvm密不可分的，正是依靠不同的操作系统下不同版本jvm的“翻译”工作，才能使编译后的字节码在不同的平台下畅通无阻的运行。</p><p>在不同操作系统下，c/c++或其他代码生成的动态链接库也会有差异，例如在window平台下会编译为<code>dll</code>文件，在linux平台下会编译为<code>so</code>文件，在mac os下会编译为<code>jnilib</code>文件。而不同平台下的jvm，会“约定俗成”的去加载某个固定类型的动态链接库文件，使得依赖于操作系统的功能可以被正常的调用，这一过程可以参考下面的图来进行理解：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ec7ac67e6fc4a60b8e417283d68d543~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在对<code>jni</code>的整体调用流程有了一定的了解后，对于它如何调用其他语言中的函数这一过程，你是否也会好奇它是怎样实现的，下面我们就通过手写一个java程序调用c++代码的例子，来理解它的调用过程。</p><h4 id="_1、准备java代码" tabindex="-1"><a class="header-anchor" href="#_1、准备java代码" aria-hidden="true">#</a> 1、准备java代码</h4><p>首先定义一个包含了<code>native</code>方法的类如下，之后我们要使用这个类中的<code>native</code>方法通过<code>jni</code>调用c++编写成的动态链接库中的方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JniTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">loadLibrary</span><span class="token punctuation">(</span><span class="token string">&quot;MyNativeDll&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">callCppMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;DLL path:&quot;</span><span class="token operator">+</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">&quot;java.library.path&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">callCppMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在代码中主要完成了以下工作：</p><ul><li>在静态代码块中，调用<code>loadLibrary</code>方法加载本地的动态链接库，参数为不包含扩展名的动态链接库库文件名。在window平台下会加载<code>dll</code>文件，在linux平台下会加载<code>so</code>文件，在mac os下会加载<code>jnilib</code>文件</li><li>声明了一个<code>native</code>方法，<code>native</code>关键字负责通知jvm这里调用方法的是本地方法，该方法在外部被定义</li><li>在<code>main</code>方法中，打印加载<code>dll</code>文件的路径，并调用本地方法</li></ul><h4 id="_2、生成头文件" tabindex="-1"><a class="header-anchor" href="#_2、生成头文件" aria-hidden="true">#</a> 2、生成头文件</h4><p>在使用c/c++来实现本地方法时，需要先创建<code>.h</code>头文件。简单的来说，c/c++程序通常由头文件（<code>.h</code>）和定义文件（<code>.c</code>或<code>.cpp</code>）组成，头文件包含了功能函数、数据接口的声明，而定义文件用于书写程序的实现。</p><p>在jdk8中可以直接使用<code>javac -h</code>指令生成c/c++语言中的头文件。如果你使用的是较早版本的jdk，需要在执行<code>javac</code>编译完成<code>class</code>文件后，再执行<code>javah -jni</code>生成c/c++风格的头文件（在jdk10的新特性中已经删除了<code>javah</code>这一指令）。我们使用的jdk8简化了这一步骤，使其可以一步完成，在命令行窗口下执行命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>javac <span class="token parameter variable">-h</span> ./jni JniTest.java
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>指令中使用 <code>-h</code>参数指定放置生成的头文件的位置，最后的参数是java源文件的名称。在这个过程中完成了两件工作，首先生成<code>class</code>文件，其次在参数指定的目录下生成头文件。生成的头文件<code>com_cn_jni_JniTest.h</code>内容如下：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;jni.h&gt;</span></span>
<span class="token comment">/* Header for class com_cn_jni_JniTest */</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_Included_com_cn_jni_JniTest</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_Included_com_cn_jni_JniTest</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span>
<span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token comment">/*
 * Class:     com_cn_jni_JniTest
 * Method:    callCppMethod
 * Signature: ()V
 */</span>
JNIEXPORT <span class="token keyword">void</span> JNICALL <span class="token function">Java_com_cn_jni_JniTest_callCppMethod</span>
  <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span><span class="token punctuation">,</span> jclass<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span>
<span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>生成的头文件和大家熟悉的 java接口有些相似，只有函数的声明而没有具体实现。简单的解释一下头文件中的代码：</p><ul><li><code>extern &quot;C&quot;</code>告诉编译器，这部分代码使用C语言规则来进行编译</li><li><code>JNIEXPORT</code>和<code>JNICALL</code>是<code>jni</code>中定义的两个宏，使用<code>JNIEXPORT</code>支持在外部程序代码中调用该动态库中的方法，使用<code>JNICALL</code>定义函数调用时参数的入栈出栈约定</li><li>函数名称由包名+类名+方法名组成，在该方法中有两个参数，通过第一个参数<code>JNIEnv *</code>的对象可以调用<code>jni.h</code>中封装好的大量函数 ，第二个参数代表着<code>native</code>方法的调用者，当java代码中定义的<code>native</code>方法是静态方法时这里的参数是<code>jclass</code>，非静态方法的参数是<code>jobject</code></li></ul><p>接下来我们创建一个<code>cpp</code>文件，引用头文件并实现其中的函数，也就是<code>native</code>方法将要实际执行的逻辑：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;com_cn_jni_JniTest.h&quot;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
 
JNIEXPORT <span class="token keyword">void</span> JNICALL <span class="token function">Java_com_cn_jni_JniTest_callCppMethod</span>
  <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span><span class="token punctuation">,</span> jclass<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Print From Cpp: \\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;I am a cpp method ! \\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在方法的实现中加入简单的<code>printf</code>打印语句，在完成方法的实现后，我们需要将上面的<code>cpp</code>文件编译为动态链接库，提供给java中的<code>native</code>方法调用，因此下面需要在window环境下安装<code>gcc</code>环境。</p><h4 id="_3、gcc环境安装" tabindex="-1"><a class="header-anchor" href="#_3、gcc环境安装" aria-hidden="true">#</a> 3、gcc环境安装</h4><p>在window环境下，如果你不希望为了生成一个<code>dll</code>就去下载体积庞大的的<code>Visual Studio</code>的话，<code>MinGW</code>是一个不错的选择，简单的说它就是一个windows版本下的<code>gcc</code>。那么估计有的同学又要问了，<code>gcc</code>是什么？简单的来说就是linux系统下<code>C/C++</code>的编译器，通过它可以将源代码编译成可执行程序。首先从下面的网址下载<code>mingw-get-setup</code>的安装程序：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>http://sourceforge.net/projects/mingw/  <span class="token comment">#32位</span>
https://sourceforge.net/projects/mingw-w64/  <span class="token comment">#64位</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>需要注意，一定要按照系统位数安装对应的版本，否则后面生成的<code>dll</code>在运行时就可能会因位数不匹配而报错，我在实验的过程中第一次就错误安装了32位的<code>MinGw</code>，导致了在程序运行过程中报了下面错误：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Exception</span> in thread <span class="token string">&quot;main&quot;</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>UnsatisfiedLinkError</span><span class="token operator">:</span> 
<span class="token class-name">F</span><span class="token operator">:</span>\\<span class="token class-name">Workspace20</span>\\unsafe<span class="token operator">-</span>test\\src\\main\\java\\com\\cn\\jni\\jni\\<span class="token class-name">MyNativeDll</span><span class="token punctuation">.</span>dll<span class="token operator">:</span> 
<span class="token class-name">Can</span>&#39;t load <span class="token constant">IA</span> <span class="token number">32</span><span class="token operator">-</span>bit <span class="token punctuation">.</span>dll on a <span class="token constant">AMD</span> <span class="token number">64</span><span class="token operator">-</span>bit platform
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>安装完成后，将<code>MinGW\\bin</code>目录加入系统环境变量<code>PATH</code>，输入下面的指令测试<code>gcc</code>是否可以使用：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>gcc <span class="token parameter variable">-v</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果能够正常输出<code>gcc</code>的版本信息，说明<code>gcc</code>安装成功：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8e48dcc69a7496e92a9a323ae74c6db~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在测试的过程中发现，如果安装的是64位的<code>mingw</code>，那么在安装完成后<code>gcc</code>就已经直接可以可用。但是如果安装的是32位的<code>mingw</code>，需要使用下面的命令单独安装<code>gcc</code>：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>mingw-get <span class="token function">install</span> gcc
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>gcc</code>安装完成后，如果还想安装<code>gdb</code>或<code>make</code>等其他指令进行调试或编译，同样可以使用强大的<code>mingw-get</code>命令进行独立安装。</p><h4 id="_4、生成动态链接库" tabindex="-1"><a class="header-anchor" href="#_4、生成动态链接库" aria-hidden="true">#</a> 4、生成动态链接库</h4><p>在<code>gcc</code>环境准备好的条件下，接下来使用下面的命令生成<code>dll</code>动态链接库：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>gcc <span class="token parameter variable">-m64</span> -Wl,--add-stdcall-alias -I<span class="token string">&quot;D:\\Program Files\\Java\\jdk1.8.0_261\\include&quot;</span> 
-I<span class="token string">&quot;D:\\Program Files\\Java\\jdk1.8.0_261\\include\\win32&quot;</span> 
<span class="token parameter variable">-shared</span> <span class="token parameter variable">-o</span> MyNativeDll.dll JniTestImpl.cpp
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单的解释一下各个参数的含义：</p><ul><li><code>-m64</code> ：将cpp代码编译为64位的应用程序</li><li><code>-Wl,--add-stdcall-alias</code>：<code>-Wl</code>表示将后面的参数传递给连接程序，参数<code>--add-stdcall-alias</code>表示带有标准调用后缀<code>@NN</code>的符号会被剥掉后缀后导出</li><li><code>-I</code>：指定头文件的路径，在生成的头文件代码中引入的<code>jni.h</code>就在这个目录下</li><li><code>-shared</code>：指定生成动态链接库，如果不使用这个标志那么外部程序将无法连接</li><li><code>-o</code>：指定目标的名称，这里将生成的动态链接库命名为<code>MyNativeDll.dll</code></li><li><code>JniTestImpl.cpp</code>：被编译的源程序文件名</li></ul><p>在指令的执行过程中，都做了什么事呢，可以参考下面这张图：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26d912fe181a467d9ea5113a79de8914~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在执行过程中，以<code>.cpp</code>源代码和<code>.h</code>头文件作为源文件，先进行了预处理、编译、汇编的操作，图中省略了这一阶段产生的一些中间文件，编译完成后生成的<code>.o</code>二进制文件相对重要，依赖这个文件，最终生成动态链接库。</p><p>在执行了上面的指令后，就会在当前目录下生成一个<code>MyNativeDll.dll</code>文件，再运行之前准备好的java代码：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16121fd1896742fa8060e171582cdbb9~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>程序报错，这是因为在默认的载入库文件的目录下没有找到我们的<code>dll</code>文件。有两种方式可以解决：</p><ul><li>直接将<code>dll</code>文件拷贝到默认的加载目录下，具体的路径可以通过<code>System.getProperty(&quot;java.library.path&quot;)</code>获取，该方法可能会获得多个目录，放在任意一个目录下即可</li><li>是在<code>VM Option</code>中修改启动参数，指定<code>dll</code>的存放目录：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token parameter variable">-Djava.library.path</span><span class="token operator">=</span>F:<span class="token punctuation">\\</span>Workspace20<span class="token punctuation">\\</span>unsafe-test<span class="token punctuation">\\</span>src<span class="token punctuation">\\</span>main<span class="token punctuation">\\</span>java<span class="token punctuation">\\</span>com<span class="token punctuation">\\</span>cn<span class="token punctuation">\\</span>jni<span class="token punctuation">\\</span>jni
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再次执行，输出结果：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">DLL</span> <span class="token value attr-value">path:F:\\Workspace20\\unsafe-test\\src\\main\\java\\com\\cn\\jni\\jni</span>
<span class="token key attr-name">Print</span> <span class="token value attr-value">From Cpp: </span>
<span class="token key attr-name">I</span> <span class="token value attr-value">am a cpp method ! </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到程序加载<code>dll</code>的路径已经切换成了它的存放路径，并且通过<code>jni</code>调用成功，输出了在c++中的代码逻辑。可以用下面的图来总结上面实现<code>jni</code>调用的过程：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c131141989149019dc08db5c1f2edbd~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在对<code>jni</code>的调用有了一个整体的了解后，如果大家对代理模式比较熟悉的话，也可以从代理模式的角度来理解<code>jni</code>，将<code>jni</code>调用过程中的各个角色带入到代理模式中：</p><ul><li>代理角色：包含<code>native</code>方法的<code>jni</code>类</li><li>实现角色：c/c++或其他语言实现的动态链接库</li><li>客户端：调用<code>native</code>方法的java类程序</li><li>接口（抽象角色）：在<code>jni</code>中接口这一角色的存在感相对薄弱，因为<code>jni</code>是跨语言的，所以说无法严格的定义一个接口并让它同时应用于java和其他语言。但是通过生成的<code>.h</code>头文件，在一定程度上实现了从<strong>接口规范</strong>上统一了java中<code>native</code>方法和其他语言中的函数</li></ul><p>以代理模式的概述图来进行描述：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/976f8c0ea5544822aea22e9879e25820~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上图在标准代理模式的基础上做了一些修改以便于理解，因为这里的接口只做规范约束作用，所以让客户端的调用过程跳过了接口，直接指向了代理角色，再由代理角色调用实现角色完成功能的调用。总的来说，<code>jni</code>起到了一个代理或中介的作用，与常见代理不同的是这里只做方法的调用，而不实现逻辑上的增强。通过这一模式，向java程序员隐藏了底层c/c++代码的实现细节，让我们专注于业务代码的编写即可。</p><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h4><p>在前面对<code>native</code>方法有了一定了解的基础上，本文介绍了<code>jni</code>的相关知识。通过本文的学习，有助于我们：</p><ul><li>理解java的为何能够做到跨平台，以及依赖操作系统的底层操作是如何实现的</li><li>了解<code>native</code>方法的调用过程，在必要时可以自己实现<code>jni</code>类接口调用</li><li><s>学到一点C/C++知识</s></li></ul><p>当然了，使用<code>jni</code>也会带来一些缺点：</p><ul><li>当在某个操作系统下使用了<code>jni</code>标准，将本地代码编译生成了动态链接库后，如果要将这个程序移植到其他操作系统，需要在新的平台重新编译代码生成动态链接库</li><li>对其他语言的不正确使用可能会造成程序出现错误，例如之前提到的使用c语言进行内存操作时未及时回收内存可能引起的内存泄漏</li><li>对其他语言的依赖过高，会提高了java和其他语言的耦合性，也提高了对项目代码的维护成本</li></ul>`,67);function p(d,t){return n(),s("div",null,[e(" more "),i])}const r=a(o,[["render",p],["__file","JNI.html.vue"]]);export{r as default};
