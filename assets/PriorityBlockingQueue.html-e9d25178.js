import{_ as n,W as s,X as a,$ as p,Z as e}from"./framework-9e67db09.js";const t={},o=e(`<p>面试官：来了啊小伙子，以前经常有小菜鸟被我虐个两三轮就不敢来了，看你忍耐力还不错，以后应该挺能加班的样子。</p><p>Hydra：那可是，我卷起来真的是连我自己都害怕啊！</p><p>面试官：那咱们今天就继续死磕队列，聊聊<code>PriorityBlockingQueue</code>吧。</p><p>Hydra：没问题啊，<code>PriorityBlockingQueue</code>是一个支持优先级的无界阻塞队列，之前介绍的队列大多是<code>FIFO</code>先进先出或<code>LIFO</code>后进先出的，<code>PriorityBlockingQueue</code>不同，可以按照自然排序或自定义排序的顺序在队列中对元素进行排序。</p><p>我还是先写一个例子吧，使用<code>offer</code>方法向队列中添加5个随机数，然后使用<code>poll</code>方法从队列中依次取出：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">PriorityBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> queue<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">PriorityBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Random</span> random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;add:&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>j<span class="token operator">+</span><span class="token string">&quot;  &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;\\r\\npoll:&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">&quot;  &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看运行结果，可以看到输出顺序与插入顺序是不同的，默认情况下最终会按照自然排序的顺序进行输出：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">add</span><span class="token punctuation">:</span>
<span class="token key attr-name">68</span> <span class="token value attr-value"> 34  40  31  44  </span>
<span class="token key attr-name">poll</span><span class="token punctuation">:</span>
<span class="token key attr-name">31</span> <span class="token value attr-value"> 34  40  44  68 </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>PriorityBlockingQueue</code>队列就像下面这个神奇的容器，不管你按照什么顺序往里塞数据，在取出的时候一定是按照排序完成后的顺序出队的。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0488565ee11c40d98d0ed2fd12d73a2c~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>面试官：怎么感觉这功能有点鸡肋啊，很多情况下我不想用自然排序怎么办？</p><p>Hydra：一看你就没仔细听我前面讲的，除了自然排序外，也可以自定义排序顺序。如果我们想改变排序算法，也可以在构造器中传入一个<code>Comparator</code>对象，像下面这么一改就可以变成降序排序了：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">PriorityBlockingQueue</span> queue<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">PriorityBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> o1<span class="token punctuation">,</span> <span class="token class-name">Integer</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> o2<span class="token operator">-</span>o1<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>面试官：我就随口问一句你还真以为我不知道啊，说一下底层是怎么实现的吧？</p><p>Hydra：在讲底层的原理之前，就不得不先提一下<strong>二叉堆</strong>的数据结构了。二叉堆是一种特殊的堆，它的结构和完全二叉树非常类似。如果父节点的值总小于子节点的值，那么它就是一个最小二叉堆，反之则是最大二叉堆，并且每个节点的左子树和右子树也是一个二叉堆。</p><p>以一个最小二叉堆为例：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ec6c1b3e105486d9d5c47e092ad8ee3~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这个最小二叉堆保存在数组中的顺序是这样的：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code>[1,2,3,4,5,6,7,8,9]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>根据它的特性，可以轻松的计算出一个节点的父节点或子节点在数组中对应的位置。假设一个元素在数组中的下标是<code>t</code>，那么父节点、左右子节点的下标计算公式如下：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">parent(t)</span> <span class="token punctuation">=</span> <span class="token value attr-value">(t - 1) &gt;&gt;&gt; 1 </span>
<span class="token key attr-name">left(t)</span> <span class="token punctuation">=</span> <span class="token value attr-value">t &lt;&lt; 1 + 1</span>
<span class="token key attr-name">right(t)</span> <span class="token punctuation">=</span> <span class="token value attr-value">t &lt;&lt; 1 + 2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上面的二叉堆中的元素6为例，它在数组中的下标是5，可以计算出它的父节点下标为2，对应元素为3：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">parent(5)</span> <span class="token punctuation">=</span> <span class="token value attr-value">100 &gt;&gt;&gt; 1 = 2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果要计算元素4的左右子节点的话，它的下标是3，计算出的子节点坐标分别为7,8，对应的元素为8,9：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">left(3)</span> <span class="token punctuation">=</span> <span class="token value attr-value">11 &lt;&lt; 1 + 1 = 7</span>
<span class="token key attr-name">right(3)</span> <span class="token punctuation">=</span> <span class="token value attr-value">11 &lt;&lt; 1 + 2 = 8</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面计算元素的数组位置过程中使用了左移右移操作，是不是感觉非常酷炫？</p><p>面试官：行了别贫了，铺垫了半点，赶紧说队列的底层原理。</p><p>Hydra：别急，下面就讲了，在<code>PriorityBlockingQueue</code>中，关键的属性有下面这些：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> queue<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> comparator<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> notEmpty<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前面我们也说了，二叉堆可以用数组的形式存储，所以队列的底层仍然是使用数组来存放元素的。在无参构造函数中，队列的初始容量是11，<code>comparator</code>为空，也就是使用元素自身的<code>compareTo</code>方法来进行比较排序。和<code>ArrayBlockingQueue</code>类似，底层通过<code>ReentrantLock</code>实现线程间的并发控制, 并使用<code>Condition</code>实现线程的等待及唤醒。</p><p>面试官：这么一看，属性和<code>ArrayBlockingQueue</code>还真是基本差不多啊，那结构就介绍到这吧，说重点，元素是怎么按照排序方法插入的？</p><p>Hydra：我们先对<code>offer</code>方法的执行流程进行分析，如果队列中元素未满，且在默认情况下<code>comparator</code>为空时，按照自然顺序排序，会执行<code>siftUpComparable</code>方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">siftUpComparable</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token class-name">T</span> x<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> key <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> x<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> parent <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span> e <span class="token operator">=</span> array<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> e<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        array<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
        k <span class="token operator">=</span> parent<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    array<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果队列为空，那么元素直接入队，如果队列中已经有元素了，那么就需要判断插入的位置了。首先获取父节点的坐标，将自己的值和父节点进行比较，可以分为两种情况：</p><ul><li>如果新节点的值比父节点大，那么说明当前父节点就是较小的元素，不需要进行调整，直接将元素添加到队尾</li><li>如果新节点的值比父节点小的话，那么就要进行<strong>上浮</strong>操作。先将父节点的值复制到子节点的位置，下一次将新节点的值与父节点的父节点进行比较。这一上浮过程会持续进行，直到新节点的值比父节点大，或新节点上浮成为根节点为止</li></ul><p>还是以上面数据插入过程为例，来演示二叉树的构建过程：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b25e1f3136f148249553fc59599cd841~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在将新元素添加到队列中后，队列中元素的计数加1，并且去唤醒阻塞在<code>notEmpty</code>上的等待线程。</p><p>面试官：那么如果不是自然排序的时候，逻辑会发生改变吗？</p><p>Hydra：如果<code>comparator</code>不为空的话，逻辑与上面的方法基本一致，唯一不同的是在进行比较时调用的是传入的自定义<code>comparator</code>的<code>compare</code>方法。</p><p>面试官：刚才你在讲<code>offer</code>方法的时候，强调了<strong>队列中元素未满</strong>这一个条件，开始的时候不是说<code>PriorityBlockingQueue</code>是一个无界队列么，那为什么还要加这一个条件？</p><p>Hydra：虽然说它是一个无界队列，但其实队列的长度上限是<code>Integer.MAX_VALUE - 8</code>，并且底层是使用的数组保存元素，在初始化数组的时候也会指定一个长度，如果超过这个长度的话，那么就需要进行扩容，执行<code>tryGrow</code>方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">tryGrow</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> oldCap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放锁</span>
    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newArray <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>allocationSpinLock <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
        <span class="token comment">//cas 加锁</span>
        <span class="token constant">UNSAFE</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> allocationSpinLockOffset<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">//计算扩容后的容量</span>
            <span class="token keyword">int</span> newCap <span class="token operator">=</span> oldCap <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>oldCap <span class="token operator">&lt;</span> <span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">?</span>
                                   <span class="token punctuation">(</span>oldCap <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token comment">// grow faster if small</span>
                                   <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 避免超出上限</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token constant">MAX_ARRAY_SIZE</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
                <span class="token keyword">int</span> minCap <span class="token operator">=</span> oldCap <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>minCap <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> minCap <span class="token operator">&gt;</span> <span class="token constant">MAX_ARRAY_SIZE</span><span class="token punctuation">)</span>
                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                newCap <span class="token operator">=</span> <span class="token constant">MAX_ARRAY_SIZE</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>newCap <span class="token operator">&gt;</span> oldCap <span class="token operator">&amp;&amp;</span> queue <span class="token operator">==</span> array<span class="token punctuation">)</span>
                <span class="token comment">//申请新的数组</span>
                newArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token comment">//释放cas锁标志位</span>
            allocationSpinLock <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//其他线程正在扩容，让出CPU</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newArray <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// back off if another thread is allocating</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//加独占式锁，拷贝原先队列中的数据</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newArray <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> queue <span class="token operator">==</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        queue <span class="token operator">=</span> newArray<span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newArray<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>先说锁的操作，在进行扩容前，会先释放独占式的<code>lock</code>，因为扩容操作需要一定的时间，如果在这段时间内还持有锁的话会降低队列的吞吐量。因此这里使用<code>cas</code>的方式保证扩容这一操作本身是排他性的，即只有一个线程来实现扩容。在完成新数组的申请后，会释放<code>cas</code>锁的标志位，并在拷贝队列中原有数据到新数组前，再次加独占式锁<code>lock</code>，保证线程间的数据安全。</p><p>至于扩容操作也很简单，假设当前数组长度为<code>n</code>，如果小于64的话那么数组长度扩为<code>2n+2</code>，如果大于64则扩为<code>1.5n</code>，并且扩容后的数组不能超过上面说的上限值。申请完成新的数组空间后，使用<code>native</code>方法实现数据的拷贝。</p><p>假设初始长度为5，当有新元素要入队时，就需要进行扩容，如图所示：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fa567c0982a4aed9c68066ac41f1341~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>面试官：ok，讲的还不赖，该说出队的方法了吧？</p><p>Hydra：嗯，有了前面的基础，出队过程理解起来也非常简单，还是以自然排序为例，看一下<code>dequeue</code>方法（省略了部分不重要的代码）：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">E</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> queue<span class="token punctuation">;</span>
    <span class="token class-name">E</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">E</span> x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> array<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    array<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token comment">// ...</span>
    <span class="token function">siftDownComparable</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> array<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// ...</span>
    size <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>    
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果队列为空，<code>dequeue</code>方法会直接返回<code>null</code>，否则返回数组中的第一个元素。在将队尾元素保存后，清除队尾节点，然后调用<code>siftDownComparable</code>方法，调整二叉堆的结构，使其成为一个新的最小二叉堆：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">siftDownComparable</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token class-name">T</span> x<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> key <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>x<span class="token punctuation">;</span>
        <span class="token keyword">int</span> half <span class="token operator">=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>           <span class="token comment">// loop while a non-leaf</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> half<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> child <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// assume left child is least</span>
            <span class="token class-name">Object</span> c <span class="token operator">=</span> array<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> right <span class="token operator">=</span> child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> array<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                c <span class="token operator">=</span> array<span class="token punctuation">[</span>child <span class="token operator">=</span> right<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> c<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            array<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>
            k <span class="token operator">=</span> child<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        array<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先解释一下<code>half</code>的作用，它用来寻找队列的中间节点，所有<strong>非叶子节点</strong>的坐标都不会超过这个<code>half</code>值。分别以树中含有奇数个节点和偶数个节点为例：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0d55dd4d7ac480cabbc75b607b3cfcc~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">[n</span><span class="token punctuation">=</span><span class="token value attr-value">9]  1001 &gt;&gt;&gt; 1 =100 =4</span>
<span class="token key attr-name">[n</span><span class="token punctuation">=</span><span class="token value attr-value">8]  1000 &gt;&gt;&gt; 1 =100 =4</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，奇数和偶数的情况下计算出的<code>half</code>值都是4，即非叶子节点的下标不会超过4，对应上图中的元素为5。</p><p>面试官：计算二叉树最后非叶子节点坐标这点知识，大一学过数据结构的新生都知道，赶紧说正题！</p><p>Hydra：着什么急啊，前面我们也说了，在将堆顶元素取出后，堆顶位置的元素出现空缺，需要调整堆结构使二叉堆的结构特性保持不变。这时候比较简单的方法就是将尾结点直接填充到堆顶，然后从堆顶开始调整结构。</p><p>因此在代码中，每次执行堆顶节点的出队后，都将尾节点取出，然后从根节点开始向下比较，这一过程可以称为<strong>下沉</strong>。下沉过程从根节点开始，首先获取左右子节点的坐标，并取出存储的元素值较小的那个，和<code>key</code>进行比较：</p><ul><li>如果<code>key</code>比左右节点都要小，那么说明找到了位置，比较结束，直接使用它替换父节点即可</li><li>否则的话，调整二叉堆结构，将较小的子节点上浮，使用它替换父节点。然后将用于比较的父节点坐标<code>k</code>下移调整为较小子节点，准备进行下一次的比较</li></ul><p>别看我白话这么一大段，估计你还是不明白，给你画个图吧，以上面的队列执行一次<code>poll</code>方法为例：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a427b271a92f4a1ea09e31e507d57f37~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>后面的操作也是以此类推，分析到这出队操作也就结束了，<code>PriorityBlockingQueue</code>也没什么其他好讲的了。</p><p>面试官：我发现你现在开始偷懒了，前面的面试里你还分一下阻塞和非阻塞方法，现在不说一下这两种方式的区别就想蒙混过关了？</p><p>Hydra：嗨，在<code>PriorityBlockingQueue</code>里阻塞和非阻塞的区别其实并不大，首先因为它是一个无界的队列，因此添加元素的操作是不会被阻塞的，如果看一下源码，你就会发现其他的添加方法<code>add</code>、<code>put</code>也是直接调用的<code>offer</code>方法。</p><p>而取出元素操作会受限制于队列是否为空，因此可能会发生阻塞，阻塞方法<code>take</code>和非阻塞的<code>poll</code>会稍有不同，如果出现队列为空的情况，<code>poll</code>会直接返回<code>null</code>，而<code>take</code>会将线程在<code>notEmpty</code>上进行阻塞，等待队列中被添加元素后唤醒。</p><p>面试官：嗯，优先级队列我们也聊的差不多了，反正都聊了这么久的队列了，不介意我们把剩余的几个也说完吧？</p><p>Hydra：没问题啊，毕竟我能有什么选择呢？</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2353c2540ded4082b261b8652aa1c3b8~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>`,69);function c(l,i){return s(),a("div",null,[p(" more "),o])}const r=n(t,[["render",c],["__file","PriorityBlockingQueue.html.vue"]]);export{r as default};
