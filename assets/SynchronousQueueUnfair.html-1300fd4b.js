import{_ as n,W as a,X as s,$ as e,Z as o}from"./framework-9e67db09.js";const p={},t=o(`<p>面试官：好了，你也休息了十分钟了，咱们接着往下聊聊<code>SynchronousQueue</code>的非公平模式吧。</p><p>Hydra：好的，有了前面公平模式的基础，非公平模式理解起来就非常简单了。公平模式下，<code>SynchronousQueue</code>底层使用的是<code>TransferQueue</code>，是一个先进先出的队列，而非公平模式与它不同，底层采用了后进先出的<code>TransferStack</code>栈来实现。</p><p>下面我们还是先写一个例子来看看效果，首先创建3个线程使用<code>put</code>方法向<code>SynchronousQueue</code>中插入数据，结束后再使用3个线程调用<code>take</code>方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">SynchronousQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> queue<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@AllArgsConstructor</span>
<span class="token keyword">class</span> <span class="token class-name">PutThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@SneakyThrows</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        queue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;putThread &quot;</span><span class="token operator">+</span>i<span class="token operator">+</span><span class="token string">&quot; end&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">TakeThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@SneakyThrows</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;takeThread take: &quot;</span><span class="token operator">+</span>queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PutThread</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span><span class="token number">3</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TakeThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行上面的代码，查看结果：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">takeThread</span> <span class="token value attr-value">take: 3</span>
<span class="token key attr-name">putThread</span> <span class="token value attr-value">3 end</span>
<span class="token key attr-name">takeThread</span> <span class="token value attr-value">take: 2</span>
<span class="token key attr-name">putThread</span> <span class="token value attr-value">2 end</span>
<span class="token key attr-name">takeThread</span> <span class="token value attr-value">take: 1</span>
<span class="token key attr-name">putThread</span> <span class="token value attr-value">1 end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，生产者线程在执行完<code>put</code>后会进行阻塞，直到有消费者线程调用<code>take</code>方法取走了数据，才会唤醒被阻塞的线程。并且，数据的出队与入队顺序是相反的，即非公平模式下采用的是后进先出的顺序。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24b84be130fd406496143fba84218b81~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>面试官：就是把结构从队列换成了栈，真就这么简单？</p><p>Hydra：并不是，包括底层节点以及出入栈的逻辑都做了相应的改变。我们先看节点，在之前的公平模式中队列的节点是<code>QNode</code>，非公平模式下栈中节点是<code>SNode</code>，定义如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">volatile</span> <span class="token class-name">SNode</span> next<span class="token punctuation">;</span> <span class="token comment">// 指向下一个节点的指针</span>
<span class="token keyword">volatile</span> <span class="token class-name">SNode</span> match<span class="token punctuation">;</span> <span class="token comment">// 存放和它进行匹配的节点</span>
<span class="token keyword">volatile</span> <span class="token class-name">Thread</span> waiter<span class="token punctuation">;</span>  <span class="token comment">// 保存阻塞的线程</span>
<span class="token class-name">Object</span> item<span class="token punctuation">;</span>                
<span class="token keyword">int</span> mode<span class="token punctuation">;</span>
<span class="token class-name">SNode</span><span class="token punctuation">(</span><span class="token class-name">Object</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> item<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和<code>QNode</code>类似，如果是生产者构建的节点，那么<code>item</code>非空，如果是消费者产生的节点，那么<code>item</code>为<code>null</code>。此外还有一个<code>mode</code>属性用来表示节点的状态，它使用<code>TransferStack</code>中定义的3个常量来表示不同状态：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">REQUEST</span>    <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//消费者</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DATA</span>       <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//生产者</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">FULFILLING</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">//匹配中状态</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>TransferStack</code>中没有携带参数的构造函数，使用一个<code>head</code>节点来标记栈顶节点：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">volatile</span> <span class="token class-name">SNode</span> head<span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>面试官：基本结构就讲到这吧，还是老规矩，先从入队操作开始分析吧。</p><p>Hydra：当栈为空、或栈顶元素的类型与自己相同时，会先创建一个<code>SNode</code>节点，并将它的<code>next</code>节点指向当前栈顶的<code>head</code>，然后将<code>head</code>指针指向自己。这个过程中通过使用<code>CAS</code>保证线程安全，如果失败则退出，在循环中采取自旋的方式不断进行尝试，直到节点入栈成功。用一张图来表示两个线程同时入栈的场景：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67ee8048aeb64673930576c45ad78176~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当节点完成入栈后，调用<code>awaitFulfill</code>方法，等待匹配的操作的到来。在这一过程中，会使节点对应的线程进行自旋或挂起操作，直到匹配操作的节点将自己唤醒，或被其他线程中断、等待超时。</p><p>当入栈后的节点是栈顶节点，或者节点的类型为<code>FULFILLING</code>匹配状态时，那么可能会马上完成匹配，因此先进行自旋，当超过自旋次数上限后再挂起。而如果节点在自旋过程中，有新的节点压入栈顶，会将非栈顶节点剩余的自旋次数直接清零，挂起线程避免浪费资源。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/035fa8064e284f9391fefc292d331ab2~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>面试官：你上面也说了，挂起的线程有可能会超时或者被中断，这时候应该怎么处理？</p><p>Hydra：当这两种情况出现时，<code>SNode</code>会将<code>match</code>属性设为自身，退出<code>awaitFulfill</code>方法，然后调用<code>clean</code>方法将对应的节点清理出栈。具体情形可分为两种情况。先说简单的情况，如果清理的是栈顶节点，那么直接将<code>head</code>节点指向它的<code>next</code>节点，即将当前栈顶结点弹出即可。</p><p>面试官：那么如果要删除的节点不是栈顶的节点呢？</p><p>Hydra：如果清理的不是栈顶节点，会稍微有一些麻烦。因为栈的底层是一个单向的链表结构，所以需要从栈顶<code>head</code>节点开始遍历，遍历到被删除节点的后继节点为止。所以在清除工作开始前，先使用了一个<code>past</code>节点标记需要删除节点的下一个节点，作为结束遍历的标记。</p><p>然后创建一个标记节点<code>p</code>，初始时指向<code>head</code>结点，开始循环，如果<code>p</code>的<code>next</code>节点不是需要被删除的节点，那么就将<code>p</code>向后移一个位置，直到找到这个需要被删除的中断或超时的节点，然后将<code>p</code>的<code>next</code>指向这个删除节点的<code>next</code>节点，在逻辑上完成链表中节点的删除。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/623f8eac030244b89ed16ef11b820ed6~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>面试官：单一类型节点的入栈应该说完了吧，接下来说说不同类型节点间是如何实现的匹配操作吧？</p><p>Hydra：好的，那我们先回顾一点上面的知识，前面说过每个节点有一个<code>mode</code>属性代表它的模式，<code>REQUEST</code>表示它是消费者，<code>DATA</code>表示是生产者，<code>FULFILLING</code>表明正处于匹配中的状态。</p><p>在一个新的线程调用方法时，先判断它的类型<code>mode</code>是什么，如果和当前栈顶<code>head</code>节点类型不同，且<code>head</code>节点的状态不为匹配中时，将它的状态设置为<code>FULFILLING|mode</code>，压入栈中。然后将尝试匹配新的<code>head</code>节点和它的<code>next</code>节点，如果匹配成功，会将<code>next</code>节点的<code>match</code>属性设置为<code>head</code>节点，唤醒挂起的<code>next</code>节点中的线程。</p><p>在完成匹配后，当前头结点对应的线程会协助推进<code>head</code>节点，将<code>head</code>指向<code>next</code>节点的下一个节点，即完成了栈顶两节点的出栈。最终消费者线程会返回匹配的生产者节点中的<code>item</code>数据值，而生产者线程也会结束运行退出。</p><p>我们以栈中当前节点为<code>DATA</code>类型，新节点为<code>REQUEST</code>类型画一张图，来直观的感受一下上面的流程：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c713610472614576b9e31f52f0cd7cef~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>面试官：总算是讲完了，能对<code>SynchronousQueue</code>做一个简单的总结吗？</p><p>Hydra：<code>SynchronousQueue</code>基于底层结构，实现了线程配对通信这一机制。在它的公平模式下使用的是先进先出（<code>FIFO</code>）的队列，非公平模式下使用的是后进先出（<code>LIFO</code>）的栈，并且<code>SynchronousQueue</code>没有使用<code>synchronized</code>或<code>ReentrantLock</code>，而是使用了大量的<code>CAS</code>操作来保证并发操作。可能我们在平常的工作中使用场景不是很多，但是在线程池的设计中使用了<code>SynchronousQueue</code>，还是有很重要的应用场景的。</p><p>面试官：讲的还行，不过刚才这些和公平模式听起来感觉区别不大啊，没有什么技术含量。这样吧，你明天过来我们加试一场，我再给你打分。</p><p>Hydra：（溜了溜了，还是找家别的靠谱公司吧……）</p>`,37);function c(l,i){return a(),s("div",null,[e(" more "),t])}const u=n(p,[["render",c],["__file","SynchronousQueueUnfair.html.vue"]]);export{u as default};
