import{_ as n,W as s,X as a,$ as e,Z as t}from"./framework-9e67db09.js";const p={},c=t(`<p>先看一道常见的面试题，下面的代码的执行结果是什么？</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list1<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>list2<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先，我们知道<code>getClas</code>方法获取的是对象运行时的类（Class），那么这个问题也就可以转化为<code>ArrayList&lt;String&gt;</code>和<code>ArrayList&lt;Integer&gt;</code>的对象在运行时对应的Class是否相同？</p><p>我们直接揭晓答案，运行上面的代码，程序会打印<code>true</code>，说明虽然在代码中声明了具体的泛型，但是两个List对象对应的Class是一样的，对它们的类型进行打印，结果都是：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>ArrayList</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>也就是说，虽然<code>ArrayList&lt;String&gt;</code>和<code>ArrayList&lt;Integer&gt;</code>在编译时是不同的类型，但是在编译完成后都被编译器简化成了<code>ArrayList</code>，这一现象，被称为泛型的<strong>类型擦除</strong>(Type Erasure)。泛型的本质是参数化类型，而类型擦除使得类型参数只存在于编译期，在运行时，<code>jvm</code>是并不知道泛型的存在的。</p><p>那么为什么要进行泛型的类型擦除呢？查阅的一些资料中，解释说类型擦除的主要目的是避免过多的创建类而造成的运行时的过度消耗。试想一下，如果用<code>List&lt;A&gt;</code>表示一个类型，再用<code>List&lt;B&gt;</code>表示另一个类型，以此类推，无疑会引起类型的数量爆炸。</p><p>在对类型擦除有了一个大致的了解后，我们再看看下面的几个问题。</p><h3 id="类型擦除做了什么" tabindex="-1"><a class="header-anchor" href="#类型擦除做了什么" aria-hidden="true">#</a> 类型擦除做了什么？</h3><p>上面我们说了，编译完成后会对泛型进行类型擦除，如果想要眼见为实，实际看一下的话应该怎么办呢？那么就需要对编译后的字节码文件进行反编译了，这里使用一个轻量级的小工具<code>Jad</code>来进行反编译（可以从这个地址进行下载：<code>https://varaneckas.com/jad/</code>）</p><p><code>Jad</code>的使用也很简单，下载解压后，把需要反编译的字节码文件放在目录下，然后在命令行里执行下面的命令就可以在同目录下生成反编译后的<code>.java</code>文件了：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>jad <span class="token parameter variable">-sjava</span> Test.class 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>好了，工具准备好了，下面我们就看一下不同情况下的类型擦除。</p><h4 id="_1、无限制类型擦除" tabindex="-1"><a class="header-anchor" href="#_1、无限制类型擦除" aria-hidden="true">#</a> 1、无限制类型擦除</h4><p>当类定义中的类型参数没有任何限制时，在类型擦除后，会被直接替换为<code>Object</code>。在下面的例子中，<code>&lt;T&gt;</code>中的类型参数T就全被替换为了<code>Object</code>（左侧为编译前的代码，右侧为通过字节码文件反编译得到的代码）：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a98ea668fbd84d4e894f6571dcb798f9~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_2、有限制类型擦除" tabindex="-1"><a class="header-anchor" href="#_2、有限制类型擦除" aria-hidden="true">#</a> 2、有限制类型擦除</h4><p>当类定义中的类型参数存在限制时，在类型擦除中替换为类型参数的上界或者下界。下面的代码中，经过擦除后<code>T</code>被替换成了<code>Integer</code>：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2db571953714ea89ac0d70853ff9ddd~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_3、擦除方法中的类型参数" tabindex="-1"><a class="header-anchor" href="#_3、擦除方法中的类型参数" aria-hidden="true">#</a> 3、擦除方法中的类型参数</h4><p>比较下面两边的代码，可以看到在擦除方法中的类型参数时，和擦除类定义中的类型参数一致，无限制时直接擦除为<code>Object</code>，有限制时则会被擦除为上界或下界：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a66ac207f62458a9ce5aa7f18a0588c~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="反射能获取泛型的类型吗" tabindex="-1"><a class="header-anchor" href="#反射能获取泛型的类型吗" aria-hidden="true">#</a> 反射能获取泛型的类型吗？</h3><p>估计对Java反射比较熟悉小伙伴要有疑问了，反射中的<code>getTypeParameters</code>方法可以获得类、数组、接口等实体的类型参数，如果类型被擦除了，那么能获取到什么呢？我们来尝试一下使用反射来获取类型参数：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>list1<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTypeParameters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行结果如下：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code>[E]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>同样，如果打印<code>Map</code>对象的参数类型：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTypeParameters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>最终也只能够获取到：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">[K,</span> <span class="token value attr-value">V]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以看到通过<code>getTypeParameters</code>方法只能获取到泛型的参数占位符，而不能获得代码中真正的泛型类型。</p><h3 id="能在指定类型的list中放入其他类型的对象吗" tabindex="-1"><a class="header-anchor" href="#能在指定类型的list中放入其他类型的对象吗" aria-hidden="true">#</a> 能在指定类型的List中放入其他类型的对象吗？</h3><p>使用泛型的好处之一，就是在编译的时候能够检查类型安全，但是通过上面的例子，我们知道<strong>运行时</strong>是没有泛型约束的，那么是不是就意味着，在运行时可以把一个类型的对象能放进另一类型的<code>List</code>呢？我们先看看正常情况下，直接调用<code>add</code>方法会有什么报错：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0a01f411d744ae0945c167f8bed3528~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当我们尝试将<code>User</code>类型的对象放入<code>String</code>类型的数组时，泛型的约束会在编译期间就进行报错，提示提供的<code>User</code>类型对象不适用于<code>String</code>类型数组。那么既然编译时不行，那么我们就在运行时写入，借助真正运行的<code>class</code>是没有泛型约束这一特性，使用反射在运行时写入：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReflectTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ReflectTest</span> reflectTest <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ReflectTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Field</span> field <span class="token operator">=</span> <span class="token class-name">ReflectTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;list&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">List</span> list<span class="token operator">=</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token punctuation">)</span> field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>reflectTest<span class="token punctuation">)</span><span class="token punctuation">;</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行上面的代码，不仅在编译期间可以通过语法检查，并且也可以正常地运行，我们使用<code>debug</code>来看一下数组中的内容：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa830aa73b4d4f7d9e727d5525b31e9e~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到虽然数组中声明的泛型类型是<code>String</code>，但是仍然成功的放入了<code>User</code>类型的对象。那么，如果我们在代码中尝试取出这个<code>User</code>对象，程序还能正常执行吗，我们在上面代码的最后再加上一句：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再次执行代码，程序运行到最后的打印语句时，报错如下：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/567a8bb8a7024ffc9b76779b2b413e32~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>异常提示<code>User</code>类型的对象无法被转换成<code>String</code>类型，这是否也就意味着，在取出对象时存在强制类型转换呢？我们来看一下<code>ArrayList</code>中<code>get</code>方法的源码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">E</span> <span class="token function">elementData</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，在取出元素时，会将这个元素强制类型转换成泛型中的类型，也就是说在上面的代码中，最后会尝试强制把<code>User</code>对象转换成<code>String</code>类型，在这一阶段程序会报错。通过这一过程，也再次证明了泛型可以对类型安全进行检测。</p><h3 id="类型擦除会引起什么问题" tabindex="-1"><a class="header-anchor" href="#类型擦除会引起什么问题" aria-hidden="true">#</a> 类型擦除会引起什么问题？</h3><p>下面我们看一个稍微有点复杂的例子，首先声明一个接口，然后创建一个实现该接口的类：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Fruit</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">T</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Apple</span> <span class="token keyword">implements</span> <span class="token class-name">Fruit</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> param<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>按照之前我们的理解，在进行类型擦除后，应该是这样的：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Fruit</span> <span class="token punctuation">{</span>
    <span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Apple</span> <span class="token keyword">implements</span> <span class="token class-name">Fruit</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> param<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，如果真是这样的话那么代码是无法运行的，因为虽然<code>Apple</code>类中也有一个<code>get</code>方法，但是与接口中的方法参数不一致，也就是说没有覆盖接口中的方法。针对这种情况，编译器会通过添加一个<strong>桥接方法</strong>来满足语法上的要求，同时保证了基于泛型的多态能够有效。我们反编译上面代码生成的字节码文件：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b165b0d594164fdc890e7feaf798ea43~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到，编译后的代码中生成了两个<code>get</code>方法。参数为<code>Object</code>的<code>get</code>方法负责实现<code>Fruit</code>接口中的同名方法，然后在实现类中又额外添加了一个参数为<code>Integer</code>的<code>get</code>方法，这个方法也就是理论上应该生成的带参数类型的方法。最终用接口方法调用额外添加的方法，通过这种方式构建了接口和实现类的关系，类似于起到了桥接的作用，因此也被称为桥接方法，最终，通过这种机制保证了泛型情况下的Java多态性。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>本文由面试中常见的一道面试题入手，介绍了java中泛型的类型擦除相关知识，通过这一过程，也便于大家理解为什么平常总是说java中的泛型是一个<strong>伪泛型</strong>，同时也有助于大家认识到java中泛型的一些缺陷。了解类型擦除的原因以及原理，相信能够方便大家在日常的工作中更好的使用泛型。</p>`,56);function o(i,l){return s(),a("div",null,[e(" more "),c])}const d=n(p,[["render",o],["__file","genericType.html.vue"]]);export{d as default};
