import{_ as e,W as o,X as c,$ as a,Z as n}from"./framework-9e67db09.js";const i={},d=n(`<p>前几天的时候，项目里有一个需求，需要一个开关控制代码中是否执行一段逻辑，于是理所当然的在<code>yml</code>文件中配置了一个属性作为开关，再配合<code>nacos</code>就可以随时改变这个值达到我们的目的，yml文件中是这样写的：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">switch</span><span class="token punctuation">:</span>
  <span class="token key atrule">turnOn</span><span class="token punctuation">:</span> on
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>程序中的代码也很简单，大致的逻辑就是下面这样，如果取到的开关字段是<code>on</code>的话，那么就执行<code>if</code>判断中的代码，否则就不执行：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">&quot;\${switch.turnOn}&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">private</span> <span class="token class-name">String</span> on<span class="token punctuation">;</span>

<span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;testn&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&quot;on&quot;</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>on<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//TODO</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是当代码实际跑起来，有意思的地方来了，我们发现判断中的代码一直不会被执行，直到debug一下，才发现这里的取到的值居然不是<code>on</code>而是<code>true</code>。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9651d6c00ce4414f96e5c186027125a2~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>看到这，是不是感觉有点意思，首先盲猜是在解析yml的过程中把<code>on</code>作为一个特殊的值进行了处理，于是我干脆再多测试了几个例子，把yml中的属性扩展到下面这些：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">switch</span><span class="token punctuation">:</span>
  <span class="token key atrule">turnOn</span><span class="token punctuation">:</span> on
  <span class="token key atrule">turnOff</span><span class="token punctuation">:</span> off
  <span class="token key atrule">turnOn2</span><span class="token punctuation">:</span> <span class="token string">&#39;on&#39;</span>
  <span class="token key atrule">turnOff2</span><span class="token punctuation">:</span> <span class="token string">&#39;off&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再执行一下代码，看一下映射后的值：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62aa41f4f0d4457ea299f032c7f4976e~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到，yml中没有带引号的<code>on</code>和<code>off</code>被转换成了<code>true</code>和<code>false</code>，带引号的则保持了原来的值不发生改变。</p><p>到这里，让我忍不住有点好奇，为什么会发生这种现象呢？于是强忍着困意翻了翻源码，硬磕了一下SpringBoot加载yml配置文件的过程，终于让我看出了点门道，下面我们一点一点细说！</p><p>因为配置文件的加载会涉及到一些SpringBoot启动的相关知识，所以如果对SpringBoot启动不是很熟悉的同学，可以先提前先看一下Hydra在古早时期写过一篇<strong>Spring Boot零配置启动原理</strong>预热一下。下面的介绍中，只会摘出一些对加载和解析配置文件比较重要的步骤进行分析，对其他无关部分进行了省略。</p><h2 id="加载监听器" tabindex="-1"><a class="header-anchor" href="#加载监听器" aria-hidden="true">#</a> 加载监听器</h2><p>当我们启动一个SpringBoot程序，在执行<code>SpringApplication.run()</code>的时候，首先在初始化<code>SpringApplication</code>的过程中，加载了11个实现了<code>ApplicationListener</code>接口的拦截器。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40b8ca76fa7844f09bad9ad3fbb31d40~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这11个自动加载的<code>ApplicationListener</code>，是在<code>spring.factories</code>中定义并通过<code>SPI</code>扩展被加载的：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fab97496769f4f73938a9173ae5bff0e~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这里列出的10个是在<code>spring-boot</code>中加载的，还有剩余的1个是在<code>spring-boot-autoconfigure</code>中加载的。其中最关键的就是<code>ConfigFileApplicationListener</code>，它和后面要讲到的配置文件的加载相关。</p><h2 id="执行run方法" tabindex="-1"><a class="header-anchor" href="#执行run方法" aria-hidden="true">#</a> 执行run方法</h2><p>在实例化完成<code>SpringApplication</code>后，会接着往下执行它的<code>run</code>方法。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05c95482d3344cb5acaf14b7aea3da0a~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到，这里通过<code>getRunListeners</code>方法获取的<code>SpringApplicationRunListeners</code>中，<code>EventPublishingRunListener</code>绑定了我们前面加载的11个监听器。但是在执行<code>starting</code>方法时，根据类型进行了过滤，最终实际只执行了<strong>4个</strong>监听器的<code>onApplicationEvent</code>方法，并没有我们希望看到的<code>ConfigFileApplicationListener</code>，让我们接着往下看。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/842e517b49c348788007c6153b74cf89~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当<code>run</code>方法执行到<code>prepareEnvironment</code>时，会创建一个<code>ApplicationEnvironmentPreparedEvent</code>类型的事件，并广播出去。这时所有的监听器中，有7个会监听到这个事件，之后会分别调用它们的<code>onApplicationEvent</code>方法，其中就有了我们心心念念的<code>ConfigFileApplicationListener</code>，接下来让我们看看它的<code>onApplicationEvent</code>方法中做了什么。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f61b6029ddd47e5a454e8ecaa154979~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在方法的调用过程中，会加载系统自己的4个后置处理器以及<code>ConfigFileApplicationListener</code>自身，一共5个后置处理器，并执行他们的<code>postProcessEnvironment</code>方法，其他4个对我们不重要可以略过，最终比较关键的步骤是创建<code>Loader</code>实例并调用它的<code>load</code>方法。</p><h2 id="加载配置文件" tabindex="-1"><a class="header-anchor" href="#加载配置文件" aria-hidden="true">#</a> 加载配置文件</h2><p>这里的<code>Loader</code>是<code>ConfigFileApplicationListener</code>的一个内部类，看一下<code>Loader</code>对象实例化的过程：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c30936c75a14d0987ebbbdda4ea1318~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在实例化<code>Loader</code>对象的过程中，再次通过SPI扩展的方式加载了两个属性文件加载器，其中的<code>YamlPropertySourceLoader</code>就和后面的yml文件的加载、解析密切关联，而另一个<code>PropertiesPropertySourceLoader</code>则负责<code>properties</code>文件的加载。创建完<code>Loader</code>实例后，接下来会调用它的<code>load</code>方法。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1607e4dc5bb74e25a4747ab4916dfccc~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在<code>load</code>方法中，会通过嵌套循环方式遍历默认配置文件存放路径，再加上默认的配置文件名称、以及不同配置文件加载器对应解析的后缀名，最终找到我们的yml配置文件。接下来，开始执行<code>loadForFileExtension</code>方法。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a9635e5076f4846b87873cc0985fab1~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在<code>loadForFileExtension</code>方法中，首先将<code>classpath:/application.yml</code>加载为<code>Resource</code>文件，接下来准备正式开始，调用了之前创建好的<code>YamlPropertySourceLoader</code>对象的<code>load</code>方法。</p><h2 id="封装node" tabindex="-1"><a class="header-anchor" href="#封装node" aria-hidden="true">#</a> 封装Node</h2><p>在<code>load</code>方法中，开始准备进行配置文件的解析与数据封装：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e47bec73004f49c19ac4676ac7d0c705~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>load</code>方法中调用了<code>OriginTrackedYmlLoader</code>对象的<code>load</code>方法，从字面意思上我们也可以理解，它的用途是原始追踪yml的加载器。中间一连串的方法调用可以忽略，直接看最后也是最重要的是一步，调用<code>OriginTrackingConstructor</code>对象的<code>getData</code>接口，来解析yml并封装成对象。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0726fdf6a49b4e2fa9cf1ea0afee4d1b~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在解析yml的过程中实际使用了<code>Composer</code>构建器来生成节点，在它的<code>getNode</code>方法中，通过解析器事件来创建节点。通常来说，它会将yml中的一组数据封装成一个<code>MappingNode</code>节点，它的内部实际上是一个<code>NodeTuple</code>组成的<code>List</code>，<code>NodeTuple</code>和<code>Map</code>的结构类似，由一对对应的<code>keyNode</code>和<code>valueNode</code>构成，结构如下：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c6e43ecf1744b5bea6daba9a70e634~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>好了，让我们再回到上面的那张方法调用流程图，它是根据文章开头的yml文件中实际内容内容绘制的，如果内容不同调用流程会发生改变，大家只需要明白这个原理，下面我们具体分析。</p><p>首先，创建一个<code>MappingNode</code>节点，并将<code>switch</code>封装成<code>keyNode</code>，然后再创建一个<code>MappingNode</code>，作为外层<code>MappingNode</code>的<code>valueNode</code>，同时存储它下面的4组属性，这也是为什么上面会出现4次循环的原因。如果有点困惑也没关系，看一下下面的这张图，就能一目了然了解它的结构。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f74cbeaaf5a5403180d3a088514dd13d~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在上图中，又引入了一种新的<code>ScalarNode</code>节点，它的用途也比较简单，简单String类型的字符串用它来封装成节点就可以了。到这里，yml中的数据被解析完成并完成了初步的封装，可能眼尖的小伙伴要问了，上面这张图中为什么在<code>ScalarNode</code>中，除了<code>value</code>还有一个<code>tag</code>属性，这个属性是干什么的呢？</p><p>在介绍它的作用前，先说一下它是怎么被确定的。这一块的逻辑比较复杂，大家可以翻一下<code>ScannerImpl</code>类<code>fetchMoreTokens</code>方法的源码，这个方法会根据yml中每一个<code>key</code>或<code>value</code>是以什么开头，来决定以什么方式进行解析，其中就包括了<code>{</code>、<code>[</code>、<code>&#39;</code>、<code>%</code>、<code>?</code>等特殊符号的情况。以解析不带任何特殊字符的字符串为例，简要的流程如下，省略了一些不重要部分：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/939aeea7aab741f89a0f5f4acd690051~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在这张图的中间步骤中，创建了两个比较重要的对象<code>ScalarToken</code>和<code>ScalarEvent</code>，其中都有一个为<code>true</code>的<code>plain</code>属性，可以理解为这个属性是否需要<strong>解释</strong>，是后面获取<code>Resolver</code>的关键属性之一。</p><p>上图中的<code>yamlImplicitResolvers</code>其实是一个提前缓存好的HashMap，已经提前存储好了一些<code>Char</code>类型字符与<code>ResolverTuple</code>的对应关系：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71f09ebdb22e40c9ab29a0445dbf2361~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当解析到属性<code>on</code>时，取出首字母<code>o</code>对应的<code>ResolverTuple</code>，其中的<code>tag</code>就是<code>tag:yaml.org.2002:bool</code>。当然了，这里也不是简单的取出就完事了，后续还会对属性进行正则表达式的匹配，看与<code>regexp</code>中的值是否能对的上，检查无误时才会返回这个<code>tag</code>。</p><p>到这里，我们就解释清楚了<code>ScalarNode</code>中<code>tag</code>属性究竟是怎么获取到的了，之后方法调用层层返回，返回到<code>OriginTrackingConstructor</code>父类<code>BaseConstructor</code>的<code>getData</code>方法中。接下来，继续执行<code>constructDocument</code>方法，完成对yml文档的解析。</p><h2 id="调用构造器" tabindex="-1"><a class="header-anchor" href="#调用构造器" aria-hidden="true">#</a> 调用构造器</h2><p>在<code>constructDocument</code>中，有两步比较重要，第一步是推断当前节点应该使用哪种类型的构造器，第二步是使用获得的构造器来重新对<code>Node</code>节点中的<code>value</code>进行赋值，简易流程如下，省去了循环遍历的部分：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d58e35bba6d540fe885c459a15b3ad57~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>推断构造器种类的过程也很简单，在父类<code>BaseConstructor</code>中，缓存了一个HashMap，存放了节点的<code>tag</code>类型到对应构造器的映射关系。在<code>getConstructor</code>方法中，就使用之前节点中存入的<code>tag</code>属性来获得具体要使用的构造器：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e0202a35c2040c099ba55d729b57878~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当<code>tag</code>为<code>bool</code>类型时，会找到<code>SafeConstruct</code>中的内部类 <code>ConstructYamlBool</code>作为构造器，并调用它的<code>construct</code>方法实例化一个对象，来作为<code>ScalarNode</code>节点的<code>value</code>的值：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1335cdc46b27491fa88adeabc53bcce1~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在<code>construct</code>方法中，取到的val就是之前的<code>on</code>，至于下面的这个<code>BOOL_VALUES</code>，也是提前初始化好的一个HashMap，里面提前存放了一些对应的映射关系，key是下面列出的这些关键字，value则是<code>Boolean</code>类型的<code>true</code>或<code>false</code>：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b071e0230644b3fb6892ddb11b5159a~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>到这里，yml中的属性解析流程就基本完成了，我们也明白了为什么yml中的<code>on</code>会被转化为<code>true</code>的原理了。至于最后，<code>Boolean</code>类型的<code>true</code>或<code>false</code>是如何被转化为的字符串，就是<code>@Value</code>注解去实现的了。</p><h2 id="思考" tabindex="-1"><a class="header-anchor" href="#思考" aria-hidden="true">#</a> 思考</h2><p>那么，下一个问题来了，既然yml文件解析中会做这样的特殊处理，那么如果换成<code>properties</code>配置文件怎么样呢？</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">sw.turnOn</span><span class="token punctuation">=</span><span class="token value attr-value">on</span>
<span class="token key attr-name">sw.turnOff</span><span class="token punctuation">=</span><span class="token value attr-value">off</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>执行一下程序，看一下结果：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74e6e58ae1694cee9c79ce0860a11fbf~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到，使用<code>properties</code>配置文件能够正常读取结果，看来是在解析的过程中没有做特殊处理，至于解析的过程，有兴趣的小伙伴可以自己去阅读一下源码。</p><p>那么，今天就写到这里，我们下期见。</p>`,70);function t(p,s){return o(),c("div",null,[a(" more "),d])}const r=e(i,[["render",t],["__file","SpringBootYmlParse.html.vue"]]);export{r as default};
